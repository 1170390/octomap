<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>octomap: octomap::OcTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">octomap
   &#160;<span id="projectnumber">1.6.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classoctomap_1_1OcTree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">octomap::OcTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>octomap main map data structure, stores 3D occupancy grid map in an <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a>.  
 <a href="classoctomap_1_1OcTree.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for octomap::OcTree:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classoctomap_1_1OcTree__inherit__graph.png" border="0" usemap="#octomap_1_1OcTree_inherit__map" alt="Inheritance graph"/></div>
<map name="octomap_1_1OcTree_inherit__map" id="octomap_1_1OcTree_inherit__map">
<area shape="rect" id="node2" href="classoctomap_1_1OccupancyOcTreeBase.html" title="octomap::OccupancyOcTree\lBase\&lt; OcTreeNode \&gt;" alt="" coords="24,118,213,165"/><area shape="rect" id="node4" href="classoctomap_1_1OcTreeBaseImpl.html" title="OcTree base class, to be used with with any kind of OcTreeDataNode." alt="" coords="5,5,232,69"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for octomap::OcTree:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classoctomap_1_1OcTree__coll__graph.png" border="0" usemap="#octomap_1_1OcTree_coll__map" alt="Collaboration graph"/></div>
<map name="octomap_1_1OcTree_coll__map" id="octomap_1_1OcTree_coll__map">
<area shape="rect" id="node2" href="classoctomap_1_1OccupancyOcTreeBase.html" title="octomap::OccupancyOcTree\lBase\&lt; OcTreeNode \&gt;" alt="" coords="1644,374,1833,421"/><area shape="rect" id="node4" href="classoctomap_1_1OcTreeBaseImpl.html" title="OcTree base class, to be used with with any kind of OcTreeDataNode." alt="" coords="1355,171,1581,235"/><area shape="rect" id="node6" href="classleaf__bbx__iterator.html" title="Bounding&#45;box leaf iterator." alt="" coords="1040,112,1157,141"/><area shape="rect" id="node8" href="classiterator__base.html" title="Base class for OcTree iterators." alt="" coords="779,112,875,141"/><area shape="rect" id="node16" href="classleaf__iterator.html" title="Iterator to iterate over all leafs of the tree." alt="" coords="1053,165,1144,195"/><area shape="rect" id="node19" href="classtree__iterator.html" title="Iterator over the complete tree (inner nodes and leafs)." alt="" coords="1053,59,1144,88"/><area shape="rect" id="node12" href="structiterator__base_1_1StackElement.html" title="Element on the internal recursion stack of the iterator." alt="" coords="5,112,192,141"/><area shape="rect" id="node22" href="classoctomath_1_1Vector3.html" title="This class represents a three&#45;dimensional vector." alt="" coords="1035,219,1163,248"/><area shape="rect" id="node26" href="classoctomap_1_1KeyRay.html" title="octomap::KeyRay" alt="" coords="764,345,889,375"/><area shape="rect" id="node30" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing." alt="" coords="25,413,172,443"/><area shape="rect" id="node39" href="classoctomap_1_1OcTree_1_1StaticMemberInitializer.html" title="Static member object which ensures that this OcTree&#39;s prototype ends up in the classIDMapping only on..." alt="" coords="1633,443,1844,490"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree_1_1StaticMemberInitializer.html">StaticMemberInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static member object which ensures that this <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a>'s prototype ends up in the classIDMapping only once.  <a href="classoctomap_1_1OcTree_1_1StaticMemberInitializer.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8a4033eb7e0956b56cb5307ecf9df579"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classleaf__iterator.html">leaf_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8a4033eb7e0956b56cb5307ecf9df579">iterator</a></td></tr>
<tr class="memitem:a55b5e366c42c06ec27cb1ce1729eddda"><td class="memItemLeft" align="right" valign="top">typedef NODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a55b5e366c42c06ec27cb1ce1729eddda">NodeType</a></td></tr>
<tr class="memdesc:a55b5e366c42c06ec27cb1ce1729eddda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the templated NODE type available from the outside.  <a href="#a55b5e366c42c06ec27cb1ce1729eddda"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf9bcd38f98a73eb0f0f2b395a8b5f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#abf9bcd38f98a73eb0f0f2b395a8b5f62">adjustKeyAtDepth</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, unsigned int depth) const </td></tr>
<tr class="memdesc:abf9bcd38f98a73eb0f0f2b395a8b5f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts a 3D key from the lowest level to correspond to a higher depth (by shifting the key values)  <a href="#abf9bcd38f98a73eb0f0f2b395a8b5f62"></a><br/></td></tr>
<tr class="memitem:a893a1fa371dbd5619dcd4f07b1c0abb6"><td class="memItemLeft" align="right" valign="top">unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a893a1fa371dbd5619dcd4f07b1c0abb6">adjustKeyAtDepth</a> (unsigned short int key, unsigned int depth) const </td></tr>
<tr class="memdesc:a893a1fa371dbd5619dcd4f07b1c0abb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts a single key value from the lowest level to correspond to a higher depth (by shifting the key value)  <a href="#a893a1fa371dbd5619dcd4f07b1c0abb6"></a><br/></td></tr>
<tr class="memitem:af2020deca883bf050e678c6436988b7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#af2020deca883bf050e678c6436988b7b">bbxSet</a> () const</td></tr>
<tr class="memitem:a03b8735676d6fe2beabac6f47755e2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8a4033eb7e0956b56cb5307ecf9df579">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a03b8735676d6fe2beabac6f47755e2ad">begin</a> (unsigned char maxDepth=0) const </td></tr>
<tr class="memitem:a39bca6c66c7420fd2062954591949d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classleaf__iterator.html">leaf_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a39bca6c66c7420fd2062954591949d49">begin_leafs</a> (unsigned char maxDepth=0) const </td></tr>
<tr class="memitem:a4bdb6f925b5eeec7765897bc1b10f821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a4bdb6f925b5eeec7765897bc1b10f821">begin_leafs_bbx</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;min, const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;max, unsigned char maxDepth=0) const </td></tr>
<tr class="memitem:aca13bfbb25a3090d3f4f0970e329f92a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aca13bfbb25a3090d3f4f0970e329f92a">begin_leafs_bbx</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;min, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;max, unsigned char maxDepth=0) const </td></tr>
<tr class="memitem:a08e9a98276ccbfcb19cf9390f9bd2f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtree__iterator.html">tree_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a08e9a98276ccbfcb19cf9390f9bd2f3f">begin_tree</a> (unsigned char maxDepth=0) const </td></tr>
<tr class="memitem:a9d998205d42dfeecfa2a359de8b38f63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9d998205d42dfeecfa2a359de8b38f63">calcNumNodes</a> () const </td></tr>
<tr class="memdesc:a9d998205d42dfeecfa2a359de8b38f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the tree to calculate the total number of nodes.  <a href="#a9d998205d42dfeecfa2a359de8b38f63"></a><br/></td></tr>
<tr class="memitem:afc368d6ff93f40ee33eca3df0b8d1967"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#afc368d6ff93f40ee33eca3df0b8d1967">castRay</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;origin, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;direction, <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">end</a>, bool ignoreUnknownCells=false, double maxRange=-1.0) const</td></tr>
<tr class="memdesc:afc368d6ff93f40ee33eca3df0b8d1967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs raycasting in 3d, similar to computeRay().  <a href="#afc368d6ff93f40ee33eca3df0b8d1967"></a><br/></td></tr>
<tr class="memitem:ad6d44e6e6e4a86e31621f67795465d45"><td class="memItemLeft" align="right" valign="top">KeyBoolMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ad6d44e6e6e4a86e31621f67795465d45">changedKeysBegin</a> ()</td></tr>
<tr class="memdesc:ad6d44e6e6e4a86e31621f67795465d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to traverse all keys of changed nodes.  <a href="#ad6d44e6e6e4a86e31621f67795465d45"></a><br/></td></tr>
<tr class="memitem:ae69d28b918feae5ae5a46e370fcff026"><td class="memItemLeft" align="right" valign="top">KeyBoolMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ae69d28b918feae5ae5a46e370fcff026">changedKeysEnd</a> ()</td></tr>
<tr class="memdesc:ae69d28b918feae5ae5a46e370fcff026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to traverse all keys of changed nodes.  <a href="#ae69d28b918feae5ae5a46e370fcff026"></a><br/></td></tr>
<tr class="memitem:a9c3152db924c4db117211056a5d0567d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9c3152db924c4db117211056a5d0567d">clear</a> ()</td></tr>
<tr class="memdesc:a9c3152db924c4db117211056a5d0567d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the complete tree structure.  <a href="#a9c3152db924c4db117211056a5d0567d"></a><br/></td></tr>
<tr class="memitem:a36031c1e3046f265257c951094a1e571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a36031c1e3046f265257c951094a1e571">computeDiscreteUpdate</a> (const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;origin, <a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;free_cells, <a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;occupied_cells, double maxrange)</td></tr>
<tr class="memdesc:a36031c1e3046f265257c951094a1e571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for insertPointCloud().  <a href="#a36031c1e3046f265257c951094a1e571"></a><br/></td></tr>
<tr class="memitem:ac8026734aa6d0dac8574b4a2c2231396"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ac8026734aa6d0dac8574b4a2c2231396">computeRay</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;origin, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">end</a>, std::vector&lt; <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &gt; &amp;ray)</td></tr>
<tr class="memdesc:ac8026734aa6d0dac8574b4a2c2231396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces a ray from origin to end (excluding), returning the coordinates of all nodes traversed by the beam.  <a href="#ac8026734aa6d0dac8574b4a2c2231396"></a><br/></td></tr>
<tr class="memitem:a48521e9a52a04f4e0e11f8feeb2ed1e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a48521e9a52a04f4e0e11f8feeb2ed1e7">computeRayKeys</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;origin, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">end</a>, <a class="el" href="classoctomap_1_1KeyRay.html">KeyRay</a> &amp;ray) const </td></tr>
<tr class="memdesc:a48521e9a52a04f4e0e11f8feeb2ed1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces a ray from origin to end (excluding), returning an <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a> of all nodes traversed by the beam.  <a href="#a48521e9a52a04f4e0e11f8feeb2ed1e7"></a><br/></td></tr>
<tr class="memitem:a5ee31e9602d5347f49fec7e0afc47e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a5ee31e9602d5347f49fec7e0afc47e22">computeUpdate</a> (const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;origin, <a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;free_cells, <a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;occupied_cells, double maxrange)</td></tr>
<tr class="memdesc:a5ee31e9602d5347f49fec7e0afc47e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for insertPointCloud().  <a href="#a5ee31e9602d5347f49fec7e0afc47e22"></a><br/></td></tr>
<tr class="memitem:a31c53676e6900005297812fbc78b10e0"><td class="memItemLeft" align="right" valign="top">unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31c53676e6900005297812fbc78b10e0">coordToKey</a> (double coordinate) const </td></tr>
<tr class="memdesc:a31c53676e6900005297812fbc78b10e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a single coordinate into a discrete key.  <a href="#a31c53676e6900005297812fbc78b10e0"></a><br/></td></tr>
<tr class="memitem:a54db9f428fc5cef9e2db88044c1f9e97"><td class="memItemLeft" align="right" valign="top">unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a54db9f428fc5cef9e2db88044c1f9e97">coordToKey</a> (double coordinate, unsigned depth) const </td></tr>
<tr class="memdesc:a54db9f428fc5cef9e2db88044c1f9e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a single coordinate into a discrete key at a given depth.  <a href="#a54db9f428fc5cef9e2db88044c1f9e97"></a><br/></td></tr>
<tr class="memitem:af7e855ad9f24517d5cc69e1b27da5372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#af7e855ad9f24517d5cc69e1b27da5372">coordToKey</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;coord) const </td></tr>
<tr class="memdesc:af7e855ad9f24517d5cc69e1b27da5372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a 3D coordinate into a 3D addressing key.  <a href="#af7e855ad9f24517d5cc69e1b27da5372"></a><br/></td></tr>
<tr class="memitem:a3a77403fc38fb945601a16938c3d6340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3a77403fc38fb945601a16938c3d6340">coordToKey</a> (double x, double y, double z) const </td></tr>
<tr class="memdesc:a3a77403fc38fb945601a16938c3d6340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a 3D coordinate into a 3D addressing key.  <a href="#a3a77403fc38fb945601a16938c3d6340"></a><br/></td></tr>
<tr class="memitem:a61df881d6eabc33f886134c9c9801166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a61df881d6eabc33f886134c9c9801166">coordToKey</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;coord, unsigned depth) const </td></tr>
<tr class="memdesc:a61df881d6eabc33f886134c9c9801166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a 3D coordinate into a 3D addressing key at a given depth.  <a href="#a61df881d6eabc33f886134c9c9801166"></a><br/></td></tr>
<tr class="memitem:ac8d62479d4ffec391bbc983b9e9f3360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ac8d62479d4ffec391bbc983b9e9f3360">coordToKey</a> (double x, double y, double z, unsigned depth) const </td></tr>
<tr class="memdesc:ac8d62479d4ffec391bbc983b9e9f3360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a 3D coordinate into a 3D addressing key at a given depth.  <a href="#ac8d62479d4ffec391bbc983b9e9f3360"></a><br/></td></tr>
<tr class="memitem:a9750ec11f04e838eb01215980c42bc17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9750ec11f04e838eb01215980c42bc17">coordToKeyChecked</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;coord, <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a9750ec11f04e838eb01215980c42bc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a>, with boundary checking.  <a href="#a9750ec11f04e838eb01215980c42bc17"></a><br/></td></tr>
<tr class="memitem:a60fc72b93838e141dd8eb1d9642d9e78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a60fc72b93838e141dd8eb1d9642d9e78">coordToKeyChecked</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;coord, unsigned depth, <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a60fc72b93838e141dd8eb1d9642d9e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a> at a certain depth, with boundary checking.  <a href="#a60fc72b93838e141dd8eb1d9642d9e78"></a><br/></td></tr>
<tr class="memitem:a733017fbfaddc7ad067465015ea4aa74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a733017fbfaddc7ad067465015ea4aa74">coordToKeyChecked</a> (double x, double y, double z, <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a733017fbfaddc7ad067465015ea4aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a>, with boundary checking.  <a href="#a733017fbfaddc7ad067465015ea4aa74"></a><br/></td></tr>
<tr class="memitem:a00f9d0f17d3d981bb79d4596a2495ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a00f9d0f17d3d981bb79d4596a2495ed9">coordToKeyChecked</a> (double x, double y, double z, unsigned depth, <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a00f9d0f17d3d981bb79d4596a2495ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a> at a certain depth, with boundary checking.  <a href="#a00f9d0f17d3d981bb79d4596a2495ed9"></a><br/></td></tr>
<tr class="memitem:ab7b2f83da4effcde89744a6f2a5caa1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ab7b2f83da4effcde89744a6f2a5caa1d">coordToKeyChecked</a> (double coordinate, unsigned short int &amp;key) const </td></tr>
<tr class="memdesc:ab7b2f83da4effcde89744a6f2a5caa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single coordinate into a discrete addressing key, with boundary checking.  <a href="#ab7b2f83da4effcde89744a6f2a5caa1d"></a><br/></td></tr>
<tr class="memitem:a0d1519c245cd5c7782e9c5652444908f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a0d1519c245cd5c7782e9c5652444908f">coordToKeyChecked</a> (double coordinate, unsigned depth, unsigned short int &amp;key) const </td></tr>
<tr class="memdesc:a0d1519c245cd5c7782e9c5652444908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single coordinate into a discrete addressing key, with boundary checking.  <a href="#a0d1519c245cd5c7782e9c5652444908f"></a><br/></td></tr>
<tr class="memitem:a787f843eb5639731742a248aa7ff800a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTree.html">OcTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree.html#a787f843eb5639731742a248aa7ff800a">create</a> () const </td></tr>
<tr class="memdesc:a787f843eb5639731742a248aa7ff800a"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual constructor: creates a new object of same type (Covariant return type requires an up-to-date compiler)  <a href="#a787f843eb5639731742a248aa7ff800a"></a><br/></td></tr>
<tr class="memitem:a36f9f15a9a4504616305a356db641de2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a36f9f15a9a4504616305a356db641de2">deleteNode</a> (double x, double y, double z, unsigned int depth=0)</td></tr>
<tr class="memdesc:a36f9f15a9a4504616305a356db641de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node (if exists) given a 3d point.  <a href="#a36f9f15a9a4504616305a356db641de2"></a><br/></td></tr>
<tr class="memitem:a31b6836c77ae48c3c550b9b786d67fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31b6836c77ae48c3c550b9b786d67fc1">deleteNode</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;value, unsigned int depth=0)</td></tr>
<tr class="memdesc:a31b6836c77ae48c3c550b9b786d67fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node (if exists) given a 3d point.  <a href="#a31b6836c77ae48c3c550b9b786d67fc1"></a><br/></td></tr>
<tr class="memitem:abc170f9acea68c32ade0fd923f4f8ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#abc170f9acea68c32ade0fd923f4f8ca8">deleteNode</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, unsigned int depth=0)</td></tr>
<tr class="memdesc:abc170f9acea68c32ade0fd923f4f8ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node (if exists) given an addressing key.  <a href="#abc170f9acea68c32ade0fd923f4f8ca8"></a><br/></td></tr>
<tr class="memitem:a4cc466fc662fe007f218fd5f51f3edba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a4cc466fc662fe007f218fd5f51f3edba">enableChangeDetection</a> (bool enable)</td></tr>
<tr class="memdesc:a4cc466fc662fe007f218fd5f51f3edba"><td class="mdescLeft">&#160;</td><td class="mdescRight">track or ignore changes while inserting scans (default: ignore)  <a href="#a4cc466fc662fe007f218fd5f51f3edba"></a><br/></td></tr>
<tr class="memitem:a265bf03a26a4975020f86560cff2c75a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8a4033eb7e0956b56cb5307ecf9df579">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">end</a> () const </td></tr>
<tr class="memitem:a61102e126b93cdfc45b9a37d25805ae8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classleaf__iterator.html">leaf_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a61102e126b93cdfc45b9a37d25805ae8">end_leafs</a> () const </td></tr>
<tr class="memitem:a7bd3f68af78f3d94fa1b6e50dcf80fc7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a7bd3f68af78f3d94fa1b6e50dcf80fc7">end_leafs_bbx</a> () const </td></tr>
<tr class="memitem:a3c16e679eea7a505d56a0113fc0e6a22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtree__iterator.html">tree_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3c16e679eea7a505d56a0113fc0e6a22">end_tree</a> () const </td></tr>
<tr class="memitem:a5b70e9de34c61f1f47c51d57e62b83ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5b70e9de34c61f1f47c51d57e62b83ee">expand</a> ()</td></tr>
<tr class="memdesc:a5b70e9de34c61f1f47c51d57e62b83ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands all pruned nodes (reverse of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31132b9fc0e9c3ffd620e53b12148443" title="Lossless compression of the octree: A node will replace all of its eight children if they have identi...">prune()</a>)  <a href="#a5b70e9de34c61f1f47c51d57e62b83ee"></a><br/></td></tr>
<tr class="memitem:abfad80701bca6864e43c76726b0df7da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#abfad80701bca6864e43c76726b0df7da">getBBXBounds</a> () const</td></tr>
<tr class="memitem:aaf505a163b211dd7678caf01dbc2f4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#aaf505a163b211dd7678caf01dbc2f4ba">getBBXCenter</a> () const</td></tr>
<tr class="memitem:adcab0b70859881d0a2ef080af2356e9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#adcab0b70859881d0a2ef080af2356e9b">getBBXMax</a> () const</td></tr>
<tr class="memitem:a764ae6dd1a5ee22858ec0ba0f72cb768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a764ae6dd1a5ee22858ec0ba0f72cb768">getBBXMin</a> () const</td></tr>
<tr class="memitem:a157244a4f44de9e982584dc87a4efa73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a157244a4f44de9e982584dc87a4efa73">getMetricMax</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>
<tr class="memdesc:a157244a4f44de9e982584dc87a4efa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum value of the bounding box of all known space in x, y, z  <a href="#a157244a4f44de9e982584dc87a4efa73"></a><br/></td></tr>
<tr class="memitem:aaa12a98cea1ddc04e0b59c21628a8a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aaa12a98cea1ddc04e0b59c21628a8a43">getMetricMax</a> (double &amp;x, double &amp;y, double &amp;z) const </td></tr>
<tr class="memdesc:aaa12a98cea1ddc04e0b59c21628a8a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum value of the bounding box of all known space in x, y, z  <a href="#aaa12a98cea1ddc04e0b59c21628a8a43"></a><br/></td></tr>
<tr class="memitem:a1e9e2f524d14d02cf214cf8149e627ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a1e9e2f524d14d02cf214cf8149e627ad">getMetricMin</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>
<tr class="memdesc:a1e9e2f524d14d02cf214cf8149e627ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum value of the bounding box of all known space in x, y, z  <a href="#a1e9e2f524d14d02cf214cf8149e627ad"></a><br/></td></tr>
<tr class="memitem:a3639ff639b1532e21e81cf32eb8489fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3639ff639b1532e21e81cf32eb8489fd">getMetricMin</a> (double &amp;x, double &amp;y, double &amp;z) const </td></tr>
<tr class="memdesc:a3639ff639b1532e21e81cf32eb8489fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum value of the bounding box of all known space in x, y, z  <a href="#a3639ff639b1532e21e81cf32eb8489fd"></a><br/></td></tr>
<tr class="memitem:ae38720a5b019b0aeece66d51dfb1e138"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ae38720a5b019b0aeece66d51dfb1e138">getMetricSize</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>
<tr class="memdesc:ae38720a5b019b0aeece66d51dfb1e138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> (all known space) in meters for x, y and z dimension.  <a href="#ae38720a5b019b0aeece66d51dfb1e138"></a><br/></td></tr>
<tr class="memitem:ab74ef7bae2862ec0c5d98963fb2bbabb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ab74ef7bae2862ec0c5d98963fb2bbabb">getMetricSize</a> (double &amp;x, double &amp;y, double &amp;z) const </td></tr>
<tr class="memdesc:ab74ef7bae2862ec0c5d98963fb2bbabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> (all known space) in meters for x, y and z dimension.  <a href="#ab74ef7bae2862ec0c5d98963fb2bbabb"></a><br/></td></tr>
<tr class="memitem:a48ba7b2eb65ed1ddbbccf04c48a560da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a48ba7b2eb65ed1ddbbccf04c48a560da">getNodeSize</a> (unsigned depth) const </td></tr>
<tr class="memitem:a44daf1f70083202ac8277dc9574b1d9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a44daf1f70083202ac8277dc9574b1d9c">getNormals</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;point, std::vector&lt; <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &gt; &amp;normals, bool unknownStatus=true) const</td></tr>
<tr class="memdesc:a44daf1f70083202ac8277dc9574b1d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a step of the marching cubes surface reconstruction algorithm to retreive the normal of the triangles that fall in the cube formed by the voxels located at the vertex of a given voxel.  <a href="#a44daf1f70083202ac8277dc9574b1d9c"></a><br/></td></tr>
<tr class="memitem:aa8ba9b01d5e67118d2fd2e64547f1b7b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aa8ba9b01d5e67118d2fd2e64547f1b7b">getNumLeafNodes</a> () const </td></tr>
<tr class="memdesc:aa8ba9b01d5e67118d2fd2e64547f1b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the tree to calculate the total number of leaf nodes.  <a href="#aa8ba9b01d5e67118d2fd2e64547f1b7b"></a><br/></td></tr>
<tr class="memitem:ad44ea7382488207c07d0fcbfff3772ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ad44ea7382488207c07d0fcbfff3772ed">getRayIntersection</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;origin, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;direction, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;center, <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;intersection, double delta=0.0) const</td></tr>
<tr class="memdesc:ad44ea7382488207c07d0fcbfff3772ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the entry point of a ray into a voxel.  <a href="#ad44ea7382488207c07d0fcbfff3772ed"></a><br/></td></tr>
<tr class="memitem:a9f052f60b7381a574d20d2e05d519ec4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9f052f60b7381a574d20d2e05d519ec4">getResolution</a> () const </td></tr>
<tr class="memitem:a35ac605b40608c122241cc530833a5b5"><td class="memItemLeft" align="right" valign="top">NODE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a35ac605b40608c122241cc530833a5b5">getRoot</a> () const </td></tr>
<tr class="memitem:a9736e60909414430b8d4acac397c6942"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9736e60909414430b8d4acac397c6942">getTreeDepth</a> () const </td></tr>
<tr class="memitem:ac05c4557c0c6f57ae46ba22bb282c0a3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree.html#ac05c4557c0c6f57ae46ba22bb282c0a3">getTreeType</a> () const </td></tr>
<tr class="memitem:a6e162cee6011e1fec8933a331817aa00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6e162cee6011e1fec8933a331817aa00">getUnknownLeafCenters</a> (<a class="el" href="namespaceoctomap.html#a435066a1f3df3ffeecc24db9cd3a5be0">point3d_list</a> &amp;node_centers, <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> pmin, <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> pmax) const </td></tr>
<tr class="memdesc:a6e162cee6011e1fec8933a331817aa00"><td class="mdescLeft">&#160;</td><td class="mdescRight">return centers of leafs that do NOT exist (but could) in a given bounding box  <a href="#a6e162cee6011e1fec8933a331817aa00"></a><br/></td></tr>
<tr class="memitem:a65963bf3e34131f640e87fbdb987d239"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a65963bf3e34131f640e87fbdb987d239">inBBX</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;p) const</td></tr>
<tr class="memitem:aba9b7931ffdfdf8b0df4c3489d015e54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#aba9b7931ffdfdf8b0df4c3489d015e54">inBBX</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key) const</td></tr>
<tr class="memitem:a3c6d38e8a7028416cd23449f14e215e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a3c6d38e8a7028416cd23449f14e215e8">insertPointCloud</a> (const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;sensor_origin, double maxrange=-1., bool lazy_eval=false, bool discretize=false)</td></tr>
<tr class="memdesc:a3c6d38e8a7028416cd23449f14e215e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a Pointcloud (in global reference frame), parallelized with OpenMP.  <a href="#a3c6d38e8a7028416cd23449f14e215e8"></a><br/></td></tr>
<tr class="memitem:a8cbe73ddb6095403a1e8a28bd4aeeb90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a8cbe73ddb6095403a1e8a28bd4aeeb90">insertPointCloud</a> (const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;sensor_origin, const <a class="el" href="namespaceoctomap.html#a6bd8a48b69816a376984cc55af3887e3">pose6d</a> &amp;frame_origin, double maxrange=-1., bool lazy_eval=false, bool discretize=false)</td></tr>
<tr class="memdesc:a8cbe73ddb6095403a1e8a28bd4aeeb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a 3d scan (transform scan before tree update), parallelized with OpenMP.  <a href="#a8cbe73ddb6095403a1e8a28bd4aeeb90"></a><br/></td></tr>
<tr class="memitem:a38596f336dede671ef08815400bc87f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a38596f336dede671ef08815400bc87f8">insertPointCloud</a> (const <a class="el" href="classoctomap_1_1ScanNode.html">ScanNode</a> &amp;scan, double maxrange=-1., bool lazy_eval=false, bool discretize=false)</td></tr>
<tr class="memdesc:a38596f336dede671ef08815400bc87f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a 3d scan (given as a ScanNode) into the tree, parallelized with OpenMP.  <a href="#a38596f336dede671ef08815400bc87f8"></a><br/></td></tr>
<tr class="memitem:a82a4f48761792bc15549eaa6d3fd03b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a82a4f48761792bc15549eaa6d3fd03b9">insertPointCloudRays</a> (const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;sensor_origin, double maxrange=-1., bool lazy_eval=false)</td></tr>
<tr class="memdesc:a82a4f48761792bc15549eaa6d3fd03b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a Pointcloud (in global reference frame), parallelized with OpenMP.  <a href="#a82a4f48761792bc15549eaa6d3fd03b9"></a><br/></td></tr>
<tr class="memitem:a3c1c2678e33a791df715affa6ea03dcd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a3c1c2678e33a791df715affa6ea03dcd">insertRay</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;origin, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">end</a>, double maxrange=-1.0, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a3c1c2678e33a791df715affa6ea03dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one ray between origin and end into the tree.  <a href="#a3c1c2678e33a791df715affa6ea03dcd"></a><br/></td></tr>
<tr class="memitem:ab6a76668ab47e521b5162c825f2eb35d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ab6a76668ab47e521b5162c825f2eb35d">integrateHit</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *occupancyNode) const</td></tr>
<tr class="memdesc:ab6a76668ab47e521b5162c825f2eb35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">integrate a "hit" measurement according to the tree's sensor model  <a href="#ab6a76668ab47e521b5162c825f2eb35d"></a><br/></td></tr>
<tr class="memitem:a3630893a9d7c18465642bde15eab21da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a3630893a9d7c18465642bde15eab21da">integrateMiss</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *occupancyNode) const</td></tr>
<tr class="memdesc:a3630893a9d7c18465642bde15eab21da"><td class="mdescLeft">&#160;</td><td class="mdescRight">integrate a "miss" measurement according to the tree's sensor model  <a href="#a3630893a9d7c18465642bde15eab21da"></a><br/></td></tr>
<tr class="memitem:ada5b1fad301a07b098c229910baa7f19"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ada5b1fad301a07b098c229910baa7f19">keyToCoord</a> (unsigned short int key, unsigned depth) const </td></tr>
<tr class="memdesc:ada5b1fad301a07b098c229910baa7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts from a discrete key at a given depth into a coordinate corresponding to the key's center  <a href="#ada5b1fad301a07b098c229910baa7f19"></a><br/></td></tr>
<tr class="memitem:ace5cef22807b62454614955a0862000a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ace5cef22807b62454614955a0862000a">keyToCoord</a> (unsigned short int key) const </td></tr>
<tr class="memdesc:ace5cef22807b62454614955a0862000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts from a discrete key at the lowest tree level into a coordinate corresponding to the key's center  <a href="#ace5cef22807b62454614955a0862000a"></a><br/></td></tr>
<tr class="memitem:a3de7659d12e4de108e0f070b3e9ac9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3de7659d12e4de108e0f070b3e9ac9d1">keyToCoord</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a3de7659d12e4de108e0f070b3e9ac9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts from an addressing key at the lowest tree level into a coordinate corresponding to the key's center  <a href="#a3de7659d12e4de108e0f070b3e9ac9d1"></a><br/></td></tr>
<tr class="memitem:a16e90e4afd4c980eca1a70be130fa929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a16e90e4afd4c980eca1a70be130fa929">keyToCoord</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, unsigned depth) const </td></tr>
<tr class="memdesc:a16e90e4afd4c980eca1a70be130fa929"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts from an addressing key at a given depth into a coordinate corresponding to the key's center  <a href="#a16e90e4afd4c980eca1a70be130fa929"></a><br/></td></tr>
<tr class="memitem:a6768db61ca2fc3ad28af756e46c34621"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6768db61ca2fc3ad28af756e46c34621">memoryFullGrid</a> () const </td></tr>
<tr class="memitem:a8ddd7627880a6b1ec1fd93695065e267"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8ddd7627880a6b1ec1fd93695065e267">memoryUsage</a> () const </td></tr>
<tr class="memitem:afca4716278c2e810da682362f979291c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#afca4716278c2e810da682362f979291c">memoryUsageNode</a> () const </td></tr>
<tr class="memitem:a7b5973d41a60f4a4ccf07ca9916c7142"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a7b5973d41a60f4a4ccf07ca9916c7142">nodeToMaxLikelihood</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *occupancyNode) const</td></tr>
<tr class="memdesc:a7b5973d41a60f4a4ccf07ca9916c7142"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts the node to the maximum likelihood value according to the tree's parameter for "occupancy"  <a href="#a7b5973d41a60f4a4ccf07ca9916c7142"></a><br/></td></tr>
<tr class="memitem:aea2310e44ca5203e12f9fbabe8a7d285"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#aea2310e44ca5203e12f9fbabe8a7d285">nodeToMaxLikelihood</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> &amp;occupancyNode) const</td></tr>
<tr class="memdesc:aea2310e44ca5203e12f9fbabe8a7d285"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts the node to the maximum likelihood value according to the tree's parameter for "occupancy"  <a href="#aea2310e44ca5203e12f9fbabe8a7d285"></a><br/></td></tr>
<tr class="memitem:a1741fb38f33d05b8df8675831cf21824"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a1741fb38f33d05b8df8675831cf21824">OCTOMAP_DEPRECATED</a> (virtual void insertScan(const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;sensor_origin, double maxrange=-1., bool pruning=true, bool lazy_eval=false))</td></tr>
<tr class="memitem:a794e2d1a868a0616c52d27f22ee1bef5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a794e2d1a868a0616c52d27f22ee1bef5">OCTOMAP_DEPRECATED</a> (virtual void insertScan(const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;sensor_origin, const <a class="el" href="namespaceoctomap.html#a6bd8a48b69816a376984cc55af3887e3">pose6d</a> &amp;frame_origin, double maxrange=-1., bool pruning=true, bool lazy_eval=false))</td></tr>
<tr class="memitem:a2d9018a31c23800af74ffce843b034e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a2d9018a31c23800af74ffce843b034e2">OCTOMAP_DEPRECATED</a> (virtual void insertScan(const <a class="el" href="classoctomap_1_1ScanNode.html">ScanNode</a> &amp;scan, double maxrange=-1., bool pruning=true, bool lazy_eval=false))</td></tr>
<tr class="memitem:a457982340024978bbd98edb81661a33a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a457982340024978bbd98edb81661a33a">OCTOMAP_DEPRECATED</a> (virtual void insertScanNaive(const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;scan, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;sensor_origin, double maxrange, bool lazy_eval=false))</td></tr>
<tr class="memitem:a08375ca02aff5117437ab2a417c8e062"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree.html#a08375ca02aff5117437ab2a417c8e062">OcTree</a> (double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5f2d51a206f715936d443367b580b6c5">resolution</a>)</td></tr>
<tr class="memdesc:a08375ca02aff5117437ab2a417c8e062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, sets resolution of leafs.  <a href="#a08375ca02aff5117437ab2a417c8e062"></a><br/></td></tr>
<tr class="memitem:a987fed229041ac30f72435983353335f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree.html#a987fed229041ac30f72435983353335f">OcTree</a> (std::string _filename)</td></tr>
<tr class="memdesc:a987fed229041ac30f72435983353335f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> from a binary file.  <a href="#a987fed229041ac30f72435983353335f"></a><br/></td></tr>
<tr class="memitem:a9e8184d78950217466f56ac031384d08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">operator==</a> (const <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a9e8184d78950217466f56ac031384d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison between two octrees, all meta data, all nodes, and the structure must be identical.  <a href="#a9e8184d78950217466f56ac031384d08"></a><br/></td></tr>
<tr class="memitem:a31132b9fc0e9c3ffd620e53b12148443"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31132b9fc0e9c3ffd620e53b12148443">prune</a> ()</td></tr>
<tr class="memdesc:a31132b9fc0e9c3ffd620e53b12148443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lossless compression of the octree: A node will replace all of its eight children if they have identical values.  <a href="#a31132b9fc0e9c3ffd620e53b12148443"></a><br/></td></tr>
<tr class="memitem:ac0c3b21746b1034254779db716cf8b22"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ac0c3b21746b1034254779db716cf8b22">readBinaryData</a> (std::istream &amp;s)</td></tr>
<tr class="memdesc:ac0c3b21746b1034254779db716cf8b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads only the data (=complete tree structure) from the input stream.  <a href="#ac0c3b21746b1034254779db716cf8b22"></a><br/></td></tr>
<tr class="memitem:a7efd5dd976f5d8caed1f689ed34c70d7"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a7efd5dd976f5d8caed1f689ed34c70d7">readBinaryNode</a> (std::istream &amp;s, <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *node) const</td></tr>
<tr class="memdesc:a7efd5dd976f5d8caed1f689ed34c70d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node from binary stream (max-likelihood value), recursively continue with all children.  <a href="#a7efd5dd976f5d8caed1f689ed34c70d7"></a><br/></td></tr>
<tr class="memitem:a041de5911e0332964e5c21cd42025955"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a041de5911e0332964e5c21cd42025955">readData</a> (std::istream &amp;s)</td></tr>
<tr class="memdesc:a041de5911e0332964e5c21cd42025955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all nodes from the input stream (without file header), for this the tree needs to be already created.  <a href="#a041de5911e0332964e5c21cd42025955"></a><br/></td></tr>
<tr class="memitem:ab1b94303bdfff6c27547c0d5f7085017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ab1b94303bdfff6c27547c0d5f7085017">resetChangeDetection</a> ()</td></tr>
<tr class="memdesc:ab1b94303bdfff6c27547c0d5f7085017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the set of changed keys. Call this after you obtained all changed nodes.  <a href="#ab1b94303bdfff6c27547c0d5f7085017"></a><br/></td></tr>
<tr class="memitem:a6db68c9dd1eef46e6343edcc9448a5ce"><td class="memItemLeft" align="right" valign="top">NODE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6db68c9dd1eef46e6343edcc9448a5ce">search</a> (double x, double y, double z, unsigned int depth=0) const </td></tr>
<tr class="memdesc:a6db68c9dd1eef46e6343edcc9448a5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search node at specified depth given a 3d point (depth=0: search full tree depth).  <a href="#a6db68c9dd1eef46e6343edcc9448a5ce"></a><br/></td></tr>
<tr class="memitem:ae73a920481fa4701c7f89c34f4ab2f15"><td class="memItemLeft" align="right" valign="top">NODE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ae73a920481fa4701c7f89c34f4ab2f15">search</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;value, unsigned int depth=0) const </td></tr>
<tr class="memdesc:ae73a920481fa4701c7f89c34f4ab2f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search node at specified depth given a 3d point (depth=0: search full tree depth) You need to check if the returned node is NULL, since it can be in unknown space.  <a href="#ae73a920481fa4701c7f89c34f4ab2f15"></a><br/></td></tr>
<tr class="memitem:ab45f108891eb301805392e164565353f"><td class="memItemLeft" align="right" valign="top">NODE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ab45f108891eb301805392e164565353f">search</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, unsigned int depth=0) const </td></tr>
<tr class="memdesc:ab45f108891eb301805392e164565353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a node at specified depth given an addressing key (depth=0: search full tree depth) You need to check if the returned node is NULL, since it can be in unknown space.  <a href="#ab45f108891eb301805392e164565353f"></a><br/></td></tr>
<tr class="memitem:a20440262a32b80919913417e87385645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a20440262a32b80919913417e87385645">setBBXMax</a> (<a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;max)</td></tr>
<tr class="memdesc:a20440262a32b80919913417e87385645"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the maximum for a query bounding box to use  <a href="#a20440262a32b80919913417e87385645"></a><br/></td></tr>
<tr class="memitem:a42cd4dc782682358ec1651ea14ec3316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a42cd4dc782682358ec1651ea14ec3316">setBBXMin</a> (<a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;min)</td></tr>
<tr class="memdesc:a42cd4dc782682358ec1651ea14ec3316"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the minimum for a query bounding box to use  <a href="#a42cd4dc782682358ec1651ea14ec3316"></a><br/></td></tr>
<tr class="memitem:a652a65d9654982e3d2f6c7528a48f2b0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a652a65d9654982e3d2f6c7528a48f2b0">setNodeValue</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, float log_odds_value, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a652a65d9654982e3d2f6c7528a48f2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log_odds value of voxel to log_odds_value.  <a href="#a652a65d9654982e3d2f6c7528a48f2b0"></a><br/></td></tr>
<tr class="memitem:a6c251537105ba0249ab2cb4299f72001"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a6c251537105ba0249ab2cb4299f72001">setNodeValue</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;value, float log_odds_value, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a6c251537105ba0249ab2cb4299f72001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log_odds value of voxel to log_odds_value.  <a href="#a6c251537105ba0249ab2cb4299f72001"></a><br/></td></tr>
<tr class="memitem:abe8ab09bde82ca578ba54eebd7c85f13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#abe8ab09bde82ca578ba54eebd7c85f13">setNodeValue</a> (double x, double y, double z, float log_odds_value, bool lazy_eval=false)</td></tr>
<tr class="memdesc:abe8ab09bde82ca578ba54eebd7c85f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log_odds value of voxel to log_odds_value.  <a href="#abe8ab09bde82ca578ba54eebd7c85f13"></a><br/></td></tr>
<tr class="memitem:a4ad4d6dd0659abbe639c5ce5f1d6c4a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a4ad4d6dd0659abbe639c5ce5f1d6c4a4">setResolution</a> (double r)</td></tr>
<tr class="memdesc:a4ad4d6dd0659abbe639c5ce5f1d6c4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the resolution of the octree, scaling all voxels. This will not preserve the (metric) scale!  <a href="#a4ad4d6dd0659abbe639c5ce5f1d6c4a4"></a><br/></td></tr>
<tr class="memitem:a61a371f276bd00516080c05a76a8be38"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a61a371f276bd00516080c05a76a8be38">size</a> () const </td></tr>
<tr class="memitem:a83584b21b3cd286552797a6a4f4b159c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a83584b21b3cd286552797a6a4f4b159c">swapContent</a> (<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a83584b21b3cd286552797a6a4f4b159c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap contents of two octrees, i.e., only the underlying pointer / tree structure.  <a href="#a83584b21b3cd286552797a6a4f4b159c"></a><br/></td></tr>
<tr class="memitem:ae0846e72f5f4e772561bc6f1f8430042"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ae0846e72f5f4e772561bc6f1f8430042">toMaxLikelihood</a> ()</td></tr>
<tr class="memdesc:ae0846e72f5f4e772561bc6f1f8430042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the maximum likelihood map by calling toMaxLikelihood on all tree nodes, setting their occupancy to the corresponding occupancy thresholds.  <a href="#ae0846e72f5f4e772561bc6f1f8430042"></a><br/></td></tr>
<tr class="memitem:a250f77b38dfd4eafe5d954979d77d0e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a250f77b38dfd4eafe5d954979d77d0e6">updateInnerOccupancy</a> ()</td></tr>
<tr class="memdesc:a250f77b38dfd4eafe5d954979d77d0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the occupancy of all inner nodes to reflect their children's occupancy.  <a href="#a250f77b38dfd4eafe5d954979d77d0e6"></a><br/></td></tr>
<tr class="memitem:a395884de10ad8de0696afb09636bc2e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a395884de10ad8de0696afb09636bc2e4">updateNode</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, float log_odds_update, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a395884de10ad8de0696afb09636bc2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate log_odds value of a voxel by changing it by log_odds_update (relative).  <a href="#a395884de10ad8de0696afb09636bc2e4"></a><br/></td></tr>
<tr class="memitem:ae64055da494c7f5254cbfe83c1e65512"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ae64055da494c7f5254cbfe83c1e65512">updateNode</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;value, float log_odds_update, bool lazy_eval=false)</td></tr>
<tr class="memdesc:ae64055da494c7f5254cbfe83c1e65512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate log_odds value of a voxel by changing it by log_odds_update (relative).  <a href="#ae64055da494c7f5254cbfe83c1e65512"></a><br/></td></tr>
<tr class="memitem:a7c46e7320b83fa8a2272069d464c4e43"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a7c46e7320b83fa8a2272069d464c4e43">updateNode</a> (double x, double y, double z, float log_odds_update, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a7c46e7320b83fa8a2272069d464c4e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate log_odds value of a voxel by changing it by log_odds_update (relative).  <a href="#a7c46e7320b83fa8a2272069d464c4e43"></a><br/></td></tr>
<tr class="memitem:abc504262dd5f8f98d479919ac2d8889e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#abc504262dd5f8f98d479919ac2d8889e">updateNode</a> (const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, bool occupied, bool lazy_eval=false)</td></tr>
<tr class="memdesc:abc504262dd5f8f98d479919ac2d8889e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate occupancy measurement.  <a href="#abc504262dd5f8f98d479919ac2d8889e"></a><br/></td></tr>
<tr class="memitem:a389413ab0fe00fabe641cb8268c903cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a389413ab0fe00fabe641cb8268c903cf">updateNode</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;value, bool occupied, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a389413ab0fe00fabe641cb8268c903cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate occupancy measurement.  <a href="#a389413ab0fe00fabe641cb8268c903cf"></a><br/></td></tr>
<tr class="memitem:a97c0ef2c7d0766f0ac0b9c861daf6d65"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a97c0ef2c7d0766f0ac0b9c861daf6d65">updateNode</a> (double x, double y, double z, bool occupied, bool lazy_eval=false)</td></tr>
<tr class="memdesc:a97c0ef2c7d0766f0ac0b9c861daf6d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate occupancy measurement.  <a href="#a97c0ef2c7d0766f0ac0b9c861daf6d65"></a><br/></td></tr>
<tr class="memitem:a1cc8f1d331e06920b8605863bdd271d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a1cc8f1d331e06920b8605863bdd271d5">updateNodeLogOdds</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *occupancyNode, const float &amp;update) const</td></tr>
<tr class="memdesc:a1cc8f1d331e06920b8605863bdd271d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">update logodds value of node by adding to the current value.  <a href="#a1cc8f1d331e06920b8605863bdd271d5"></a><br/></td></tr>
<tr class="memitem:a055f971c772215c974c2fe4cec183e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a055f971c772215c974c2fe4cec183e9c">useBBXLimit</a> (bool enable)</td></tr>
<tr class="memdesc:a055f971c772215c974c2fe4cec183e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use or ignore BBX limit (default: ignore)  <a href="#a055f971c772215c974c2fe4cec183e9c"></a><br/></td></tr>
<tr class="memitem:aaeb5a6148103a127b1f94860803812ae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aaeb5a6148103a127b1f94860803812ae">volume</a> ()</td></tr>
<tr class="memitem:a16fa3cdb461dbe1889587c363e60a48f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a16fa3cdb461dbe1889587c363e60a48f">writeBinaryData</a> (std::ostream &amp;s) const</td></tr>
<tr class="memdesc:a16fa3cdb461dbe1889587c363e60a48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data of the tree (without header) to the stream, recursively calling writeBinaryNode (starting with root)  <a href="#a16fa3cdb461dbe1889587c363e60a48f"></a><br/></td></tr>
<tr class="memitem:a2bf24c5a91cb4f0d6e478181c98b75c3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a2bf24c5a91cb4f0d6e478181c98b75c3">writeBinaryNode</a> (std::ostream &amp;s, const <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *node) const</td></tr>
<tr class="memdesc:a2bf24c5a91cb4f0d6e478181c98b75c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write node to binary stream (max-likelihood value), recursively continue with all children.  <a href="#a2bf24c5a91cb4f0d6e478181c98b75c3"></a><br/></td></tr>
<tr class="memitem:a8e86a2b65a21ae07837ce08dc82aa1af"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8e86a2b65a21ae07837ce08dc82aa1af">writeData</a> (std::ostream &amp;s) const </td></tr>
<tr class="memdesc:a8e86a2b65a21ae07837ce08dc82aa1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write complete state of tree to stream (without file header) unmodified. Pruning the tree first produces smaller files (lossless compression)  <a href="#a8e86a2b65a21ae07837ce08dc82aa1af"></a><br/></td></tr>
<tr class="memitem:a1880c124585d9699f245b427ffb9571b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree.html#a1880c124585d9699f245b427ffb9571b">~OcTree</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af06c439b33e1619dcf610c3bcce766c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#af06c439b33e1619dcf610c3bcce766c5">calcMinMax</a> ()</td></tr>
<tr class="memdesc:af06c439b33e1619dcf610c3bcce766c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">recalculates min and max in x, y, z. Does nothing when tree size didn't change.  <a href="#af06c439b33e1619dcf610c3bcce766c5"></a><br/></td></tr>
<tr class="memitem:a9f4735a1c05790fa4228e1cb35c65f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9f4735a1c05790fa4228e1cb35c65f7c">calcNumNodesRecurs</a> (NODE *node, size_t &amp;num_nodes) const </td></tr>
<tr class="memitem:ae00cde0edc00cfad27057ec438f8c9a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ae00cde0edc00cfad27057ec438f8c9a3">deleteNodeRecurs</a> (NODE *node, unsigned int depth, unsigned int max_depth, const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key)</td></tr>
<tr class="memdesc:ae00cde0edc00cfad27057ec438f8c9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive call of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a36f9f15a9a4504616305a356db641de2" title="Delete a node (if exists) given a 3d point.">deleteNode()</a>  <a href="#ae00cde0edc00cfad27057ec438f8c9a3"></a><br/></td></tr>
<tr class="memitem:a57f15113fcb61fee6b677a3956937f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a57f15113fcb61fee6b677a3956937f7d">expandRecurs</a> (NODE *node, unsigned int depth, unsigned int max_depth)</td></tr>
<tr class="memdesc:a57f15113fcb61fee6b677a3956937f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive call of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5b70e9de34c61f1f47c51d57e62b83ee" title="Expands all pruned nodes (reverse of prune())">expand()</a>  <a href="#a57f15113fcb61fee6b677a3956937f7d"></a><br/></td></tr>
<tr class="memitem:af1ef3f9fa8a01299183c994c37d8308a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#af1ef3f9fa8a01299183c994c37d8308a">getNumLeafNodesRecurs</a> (const NODE *parent) const </td></tr>
<tr class="memitem:ac054acf73b2f7e8f509c7fa695169aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ac054acf73b2f7e8f509c7fa695169aa8">init</a> ()</td></tr>
<tr class="memdesc:ac054acf73b2f7e8f509c7fa695169aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize non-trivial members, helper for constructors  <a href="#ac054acf73b2f7e8f509c7fa695169aa8"></a><br/></td></tr>
<tr class="memitem:aaa4024dfb0d825e8e10299ad9d55ff8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#aaa4024dfb0d825e8e10299ad9d55ff8f">integrateMissOnRay</a> (const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;origin, const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">end</a>, bool lazy_eval=false)</td></tr>
<tr class="memdesc:aaa4024dfb0d825e8e10299ad9d55ff8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces a ray from origin to end and updates all voxels on the way as free.  <a href="#aaa4024dfb0d825e8e10299ad9d55ff8f"></a><br/></td></tr>
<tr class="memitem:a97fc800f63229de112a223cfef6e8c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a97fc800f63229de112a223cfef6e8c84">pruneRecurs</a> (NODE *node, unsigned int depth, unsigned int max_depth, unsigned int &amp;num_pruned)</td></tr>
<tr class="memdesc:a97fc800f63229de112a223cfef6e8c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive call of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31132b9fc0e9c3ffd620e53b12148443" title="Lossless compression of the octree: A node will replace all of its eight children if they have identi...">prune()</a>  <a href="#a97fc800f63229de112a223cfef6e8c84"></a><br/></td></tr>
<tr class="memitem:af68159ed27df340f6930ec481a8b7a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#af68159ed27df340f6930ec481a8b7a53">setNodeValueRecurs</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *node, bool node_just_created, const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, unsigned int depth, const float &amp;log_odds_value, bool lazy_eval=false)</td></tr>
<tr class="memitem:afd9a64204726215c65c80386ada661dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#afd9a64204726215c65c80386ada661dd">toMaxLikelihoodRecurs</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *node, unsigned int depth, unsigned int max_depth)</td></tr>
<tr class="memitem:ae79d100be1e5eb3d55c1a91751df28c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ae79d100be1e5eb3d55c1a91751df28c8">updateInnerOccupancyRecurs</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *node, unsigned int depth)</td></tr>
<tr class="memitem:abf29213fc595d17e2a83aed551166473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#abf29213fc595d17e2a83aed551166473">updateNodeRecurs</a> (<a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> *node, bool node_just_created, const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;key, unsigned int depth, const float &amp;log_odds_update, bool lazy_eval=false)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abdb60fb3020a5bb347167d1bfaa65335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#abdb60fb3020a5bb347167d1bfaa65335">bbx_max</a></td></tr>
<tr class="memitem:a7a40102a8e6d48ec09d576482a8fde9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a7a40102a8e6d48ec09d576482a8fde9e">bbx_max_key</a></td></tr>
<tr class="memitem:a1a0841eef190e9eb6c07db41bc047f8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a1a0841eef190e9eb6c07db41bc047f8b">bbx_min</a></td></tr>
<tr class="memitem:afd858331fd9954e545383520e324ff29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#afd858331fd9954e545383520e324ff29">bbx_min_key</a></td></tr>
<tr class="memitem:a842d31e238713bfc8afe708e97b859b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a5f98f11c602d9fefec29ff55763e1d49">KeyBoolMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a842d31e238713bfc8afe708e97b859b1">changed_keys</a></td></tr>
<tr class="memdesc:a842d31e238713bfc8afe708e97b859b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of leaf keys (lowest level) which changed since last resetChangeDetection.  <a href="#a842d31e238713bfc8afe708e97b859b1"></a><br/></td></tr>
<tr class="memitem:a6bd58a85177ebd36b1dfed18a95ab965"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoctomap_1_1KeyRay.html">KeyRay</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6bd58a85177ebd36b1dfed18a95ab965">keyrays</a></td></tr>
<tr class="memdesc:a6bd58a85177ebd36b1dfed18a95ab965"><td class="mdescLeft">&#160;</td><td class="mdescRight">data structure for ray casting, array for multithreading  <a href="#a6bd58a85177ebd36b1dfed18a95ab965"></a><br/></td></tr>
<tr class="memitem:a0d644d0caf31705312a94d8091ead298"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a0d644d0caf31705312a94d8091ead298">leaf_iterator_bbx_end</a></td></tr>
<tr class="memitem:af265e3a9c552cd90eb1101cb248c2736"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classleaf__iterator.html">leaf_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#af265e3a9c552cd90eb1101cb248c2736">leaf_iterator_end</a></td></tr>
<tr class="memitem:a0a3d5448647090d1ef19eae1e3fafd0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a0a3d5448647090d1ef19eae1e3fafd0c">max_value</a> [3]</td></tr>
<tr class="memdesc:a0a3d5448647090d1ef19eae1e3fafd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">max in x, y, z  <a href="#a0a3d5448647090d1ef19eae1e3fafd0c"></a><br/></td></tr>
<tr class="memitem:aecaa47e50bb18d56d9401854354fbd90"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aecaa47e50bb18d56d9401854354fbd90">min_value</a> [3]</td></tr>
<tr class="memdesc:aecaa47e50bb18d56d9401854354fbd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">min in x, y, z contains the size of a voxel at level i (0: root node). tree_depth+1 levels (incl. 0)  <a href="#aecaa47e50bb18d56d9401854354fbd90"></a><br/></td></tr>
<tr class="memitem:a5f2d51a206f715936d443367b580b6c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5f2d51a206f715936d443367b580b6c5">resolution</a></td></tr>
<tr class="memdesc:a5f2d51a206f715936d443367b580b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">in meters  <a href="#a5f2d51a206f715936d443367b580b6c5"></a><br/></td></tr>
<tr class="memitem:ac7b422a040cdd65ae18e26334bb03f35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ac7b422a040cdd65ae18e26334bb03f35">resolution_factor</a></td></tr>
<tr class="memdesc:ac7b422a040cdd65ae18e26334bb03f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">= 1. / resolution  <a href="#ac7b422a040cdd65ae18e26334bb03f35"></a><br/></td></tr>
<tr class="memitem:aebd8f6d931c30b559055a3ad3376aa11"><td class="memItemLeft" align="right" valign="top">NODE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aebd8f6d931c30b559055a3ad3376aa11">root</a></td></tr>
<tr class="memdesc:aebd8f6d931c30b559055a3ad3376aa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root NODE, NULL for empty tree.  <a href="#aebd8f6d931c30b559055a3ad3376aa11"></a><br/></td></tr>
<tr class="memitem:acb759f973505d25813717166300266b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#acb759f973505d25813717166300266b1">size_changed</a></td></tr>
<tr class="memitem:aeb09478c7fb5dbe6fc271b066876584e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aeb09478c7fb5dbe6fc271b066876584e">sizeLookupTable</a></td></tr>
<tr class="memitem:ac1c4753f4bf09c85d8856f1151bcee56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ac1c4753f4bf09c85d8856f1151bcee56">tree_center</a></td></tr>
<tr class="memitem:a54a46a920d1b6bea565ecb3aec4836e0"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a54a46a920d1b6bea565ecb3aec4836e0">tree_depth</a></td></tr>
<tr class="memdesc:a54a46a920d1b6bea565ecb3aec4836e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum tree depth is fixed to 16 currently.  <a href="#a54a46a920d1b6bea565ecb3aec4836e0"></a><br/></td></tr>
<tr class="memitem:a6d0a6c8b9d69baaabff6d840c531a223"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtree__iterator.html">tree_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6d0a6c8b9d69baaabff6d840c531a223">tree_iterator_end</a></td></tr>
<tr class="memitem:a09f8c5c9275c0d56af2f8c9b5bb463c6"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a09f8c5c9275c0d56af2f8c9b5bb463c6">tree_max_val</a></td></tr>
<tr class="memitem:ad8ffbc2b6a76a338095974e7b03a7365"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ad8ffbc2b6a76a338095974e7b03a7365">tree_size</a></td></tr>
<tr class="memdesc:ad8ffbc2b6a76a338095974e7b03a7365"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nodes in tree flag to denote whether the octree extent changed (for lazy min/max eval)  <a href="#ad8ffbc2b6a76a338095974e7b03a7365"></a><br/></td></tr>
<tr class="memitem:ab2ad82f344d43a0558d69b9113a4c257"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ab2ad82f344d43a0558d69b9113a4c257">use_bbx_limit</a></td></tr>
<tr class="memdesc:ab2ad82f344d43a0558d69b9113a4c257"><td class="mdescLeft">&#160;</td><td class="mdescRight">use bounding box for queries (needs to be set)?  <a href="#ab2ad82f344d43a0558d69b9113a4c257"></a><br/></td></tr>
<tr class="memitem:a8a220400856023e41706e810fe724508"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#a8a220400856023e41706e810fe724508">use_change_detection</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:af913dc3ca39d6b18855b54d6d52e5307"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classoctomap_1_1OcTree_1_1StaticMemberInitializer.html">StaticMemberInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoctomap_1_1OcTree.html#af913dc3ca39d6b18855b54d6d52e5307">ocTreeMemberInit</a></td></tr>
<tr class="memdesc:af913dc3ca39d6b18855b54d6d52e5307"><td class="mdescLeft">&#160;</td><td class="mdescRight">to ensure static initialization (only once)  <a href="#af913dc3ca39d6b18855b54d6d52e5307"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>octomap main map data structure, stores 3D occupancy grid map in an <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a>. </p>
<p>Basic functionality is implemented in <a class="el" href="classoctomap_1_1OcTreeBase.html">OcTreeBase</a>. </p>
</div><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a8a4033eb7e0956b56cb5307ecf9df579"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classleaf__iterator.html">leaf_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8a4033eb7e0956b56cb5307ecf9df579">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55b5e366c42c06ec27cb1ce1729eddda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef NODE <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::<a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a55b5e366c42c06ec27cb1ce1729eddda">NodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the templated NODE type available from the outside. </p>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a08375ca02aff5117437ab2a417c8e062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">octomap::OcTree::OcTree </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, sets resolution of leafs. </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTree.html#a787f843eb5639731742a248aa7ff800a">create()</a>, and <a class="el" href="classoctomap_1_1OcTree_1_1StaticMemberInitializer.html#a77d9e0b5f6051bb15c1bd8f40025daec">octomap::OcTree::StaticMemberInitializer::StaticMemberInitializer()</a>.</p>

</div>
</div>
<a class="anchor" id="a987fed229041ac30f72435983353335f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">octomap::OcTree::OcTree </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> from a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_filename</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1880c124585d9699f245b427ffb9571b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual octomap::OcTree::~OcTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="abf9bcd38f98a73eb0f0f2b395a8b5f62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::adjustKeyAtDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts a 3D key from the lowest level to correspond to a higher depth (by shifting the key values) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Input key, at the lowest tree level </td></tr>
    <tr><td class="paramname">depth</td><td>Target depth level for the new key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key for the new depth level </dd></dl>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#abf9bcd38f98a73eb0f0f2b395a8b5f62">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::adjustKeyAtDepth()</a>.</p>

</div>
</div>
<a class="anchor" id="a893a1fa371dbd5619dcd4f07b1c0abb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short int <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::adjustKeyAtDepth </td>
          <td>(</td>
          <td class="paramtype">unsigned short int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts a single key value from the lowest level to correspond to a higher depth (by shifting the key value) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Input key, at the lowest tree level </td></tr>
    <tr><td class="paramname">depth</td><td>Target depth level for the new key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key for the new depth level </dd></dl>

</div>
</div>
<a class="anchor" id="af2020deca883bf050e678c6436988b7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::bbxSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03b8735676d6fe2beabac6f47755e2ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8a4033eb7e0956b56cb5307ecf9df579">iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>beginning of the tree as leaf iterator </dd></dl>

<p>Referenced by <a class="el" href="bt2vrml_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a39bca6c66c7420fd2062954591949d49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classleaf__iterator.html">leaf_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::begin_leafs </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>beginning of the tree as leaf iterator </dd></dl>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeStamped.html#a480c6d2c4308c8b5017bed9f2b5f56b1">octomap::OcTreeStamped::degradeOutdatedNodes()</a>, and <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a4bdb6f925b5eeec7765897bc1b10f821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::begin_leafs_bbx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>beginning of the tree as leaf iterator in a bounding box </dd></dl>

</div>
</div>
<a class="anchor" id="aca13bfbb25a3090d3f4f0970e329f92a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::begin_leafs_bbx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>beginning of the tree as leaf iterator in a bounding box </dd></dl>

</div>
</div>
<a class="anchor" id="a08e9a98276ccbfcb19cf9390f9bd2f3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree__iterator.html">tree_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::begin_tree </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>beginning of the tree as iterator to all nodes (incl. inner) </dd></dl>

<p>Referenced by <a class="el" href="graph2tree_8cpp.html#a48a6bc54cffc48e72d9b5a7712757ad4">calcThresholdedNodes()</a>, <a class="el" href="test__iterators_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::operator==()</a>, <a class="el" href="test__changedkeys_8cpp.html#a427f20c2f8fea069265c6d60e46fc695">printChanges()</a>, and <a class="el" href="classoctomap_1_1ColorOcTree.html#a7e6e3776997e10b7d651b82fd427c8bc">octomap::ColorOcTree::writeColorHistogram()</a>.</p>

</div>
</div>
<a class="anchor" id="af06c439b33e1619dcf610c3bcce766c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::calcMinMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recalculates min and max in x, y, z. Does nothing when tree size didn't change. </p>

</div>
</div>
<a class="anchor" id="a9d998205d42dfeecfa2a359de8b38f63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::calcNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverses the tree to calculate the total number of nodes. </p>

<p>Referenced by <a class="el" href="test__iterators_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html#ac0c3b21746b1034254779db716cf8b22">octomap::OccupancyOcTreeBase&lt; NODE &gt;::readBinaryData()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4735a1c05790fa4228e1cb35c65f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::calcNumNodesRecurs </td>
          <td>(</td>
          <td class="paramtype">NODE *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc368d6ff93f40ee33eca3df0b8d1967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::castRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreUnknownCells</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxRange</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs raycasting in 3d, similar to computeRay(). </p>
<p>Can be called in parallel e.g. with OpenMP for a speedup.</p>
<p>A ray is cast from origin with a given direction, the first occupied cell is returned (as center coordinate). If the starting coordinate is already occupied in the tree, this coordinate will be returned as a hit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>starting coordinate of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>A vector pointing in the direction of the raycast. Does not need to be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>returns the center of the cell that was hit by the ray, if successful </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignoreUnknownCells</td><td>whether unknown cells are ignored. If false (default), the raycast aborts when an unknown cell is hit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRange</td><td>Maximum range after which the raycast is aborted (&lt;= 0: no limit, default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not an occupied cell was hit </dd></dl>

</div>
</div>
<a class="anchor" id="ad6d44e6e6e4a86e31621f67795465d45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KeyBoolMap::const_iterator <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::changedKeysBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator to traverse all keys of changed nodes. </p>
<p>you need to enableChangeDetection() first. Here, an OcTreeKey always refers to a node at the lowest tree level (its size is the minimum tree resolution) </p>

</div>
</div>
<a class="anchor" id="ae69d28b918feae5ae5a46e370fcff026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KeyBoolMap::const_iterator <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::changedKeysEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator to traverse all keys of changed nodes. </p>

</div>
</div>
<a class="anchor" id="a9c3152db924c4db117211056a5d0567d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the complete tree structure. </p>

</div>
</div>
<a class="anchor" id="a36031c1e3046f265257c951094a1e571"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::computeDiscreteUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>free_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>occupied_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for insertPointCloud(). </p>
<p>Computes all octree nodes affected by the point cloud integration at once. Here, occupied nodes have a preference over free ones. This function first discretizes the scan with the octree grid, which results in fewer raycasts (=speedup) but a slightly different result than computeUpdate().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>point cloud measurement to be integrated </td></tr>
    <tr><td class="paramname">origin</td><td>origin of the sensor for ray casting </td></tr>
    <tr><td class="paramname">free_cells</td><td>keys of nodes to be cleared </td></tr>
    <tr><td class="paramname">occupied_cells</td><td>keys of nodes to be marked occupied </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range for raycasting (-1: unlimited) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8026734aa6d0dac8574b4a2c2231396"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::computeRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traces a ray from origin to end (excluding), returning the coordinates of all nodes traversed by the beam. </p>
<p>You still need to check if a node at that coordinate exists (e.g. with <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6db68c9dd1eef46e6343edcc9448a5ce" title="Search node at specified depth given a 3d point (depth=0: search full tree depth).">search()</a>). </p>
<dl class="section note"><dt>Note</dt><dd>: use the faster computeRayKeys method if possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>start coordinate of ray </td></tr>
    <tr><td class="paramname">end</td><td>end coordinate of ray </td></tr>
    <tr><td class="paramname">ray</td><td><a class="el" href="classoctomap_1_1KeyRay.html">KeyRay</a> structure that holds the keys of all nodes traversed by the ray, excluding "end" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of operation. Returning false usually means that one of the coordinates is out of the <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a>'s range </dd></dl>

</div>
</div>
<a class="anchor" id="a48521e9a52a04f4e0e11f8feeb2ed1e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::computeRayKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1KeyRay.html">KeyRay</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traces a ray from origin to end (excluding), returning an <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a> of all nodes traversed by the beam. </p>
<p>You still need to check if a node at that coordinate exists (e.g. with <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a6db68c9dd1eef46e6343edcc9448a5ce" title="Search node at specified depth given a 3d point (depth=0: search full tree depth).">search()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>start coordinate of ray </td></tr>
    <tr><td class="paramname">end</td><td>end coordinate of ray </td></tr>
    <tr><td class="paramname">ray</td><td><a class="el" href="classoctomap_1_1KeyRay.html">KeyRay</a> structure that holds the keys of all nodes traversed by the ray, excluding "end" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of operation. Returning false usually means that one of the coordinates is out of the <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a>'s range </dd></dl>

<p>Reimplemented in <a class="el" href="classoctomap_1_1OcTreeBaseSE.html#a9c2e58d0d68e297d8ce2e75ee818baa3">octomap::OcTreeBaseSE&lt; NODE &gt;</a>.</p>

<p>References <a class="el" href="classoctomap_1_1KeyRay.html#aae1b836a2a3413e4eec5b299a849bbc0">octomap::KeyRay::addKey()</a>, <a class="el" href="classoctomath_1_1Vector3.html#a56bf8a27cdb62290e93b71cb5fa2619a">octomath::Vector3::norm()</a>, <a class="el" href="octomap__types_8h.html#ab0641214b665cad32c6f3c8f1cc8ff69">OCTOMAP_WARNING_STR</a>, <a class="el" href="classoctomap_1_1KeyRay.html#a4d0858a3f520f16b0a3327a3d4e4bdf2">octomap::KeyRay::reset()</a>, <a class="el" href="classoctomap_1_1KeyRay.html#a4cd5f784db4af2aad7862d9e818f22e2">octomap::KeyRay::size()</a>, and <a class="el" href="classoctomap_1_1KeyRay.html#a1dc520299a7990137357bdabf75d424e">octomap::KeyRay::sizeMax()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee31e9602d5347f49fec7e0afc47e22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::computeUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>free_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#aceae2f852393087f735de263074245df">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>occupied_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for insertPointCloud(). </p>
<p>Computes all octree nodes affected by the point cloud integration at once. Here, occupied nodes have a preference over free ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>point cloud measurement to be integrated </td></tr>
    <tr><td class="paramname">origin</td><td>origin of the sensor for ray casting </td></tr>
    <tr><td class="paramname">free_cells</td><td>keys of nodes to be cleared </td></tr>
    <tr><td class="paramname">occupied_cells</td><td>keys of nodes to be marked occupied </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range for raycasting (-1: unlimited) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31c53676e6900005297812fbc78b10e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short int <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::coordToKey </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coordinate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a single coordinate into a discrete key. </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#af7e855ad9f24517d5cc69e1b27da5372">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::coordToKey()</a>.</p>

</div>
</div>
<a class="anchor" id="a54db9f428fc5cef9e2db88044c1f9e97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short int <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKey </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a single coordinate into a discrete key at a given depth. </p>

</div>
</div>
<a class="anchor" id="af7e855ad9f24517d5cc69e1b27da5372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::coordToKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a 3D coordinate into a 3D addressing key. </p>

</div>
</div>
<a class="anchor" id="a3a77403fc38fb945601a16938c3d6340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::coordToKey </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a 3D coordinate into a 3D addressing key. </p>

</div>
</div>
<a class="anchor" id="a61df881d6eabc33f886134c9c9801166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::coordToKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a 3D coordinate into a 3D addressing key at a given depth. </p>

</div>
</div>
<a class="anchor" id="ac8d62479d4ffec391bbc983b9e9f3360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::coordToKey </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a 3D coordinate into a 3D addressing key at a given depth. </p>

</div>
</div>
<a class="anchor" id="a9750ec11f04e838eb01215980c42bc17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKeyChecked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a>, with boundary checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>3d coordinate of a point </td></tr>
    <tr><td class="paramname">key</td><td>values that will be computed, an array of fixed size 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if point is within the octree (valid), false otherwise </dd></dl>

<p>Referenced by <a class="el" href="classoctomap_1_1ColorOcTree.html#ac49edcee47aa7187bd7ad46ff81567dd">octomap::ColorOcTree::averageNodeColor()</a>, <a class="el" href="classoctomap_1_1ColorOcTree.html#ace682377b828ab92505b393612a3712f">octomap::ColorOcTree::integrateNodeColor()</a>, <a class="el" href="test__pruning_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="classoctomap_1_1ColorOcTree.html#af27a39cc543a9d9004beb72266736806">octomap::ColorOcTree::setNodeColor()</a>, and <a class="el" href="classoctomap_1_1CountingOcTree.html#ac3c5e35e6d51aeafad261b3cd1301f1e">octomap::CountingOcTree::updateNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a60fc72b93838e141dd8eb1d9642d9e78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKeyChecked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a> at a certain depth, with boundary checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>3d coordinate of a point </td></tr>
    <tr><td class="paramname">depth</td><td>level of the key from the top </td></tr>
    <tr><td class="paramname">key</td><td>values that will be computed, an array of fixed size 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if point is within the octree (valid), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a733017fbfaddc7ad067465015ea4aa74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKeyChecked </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a>, with boundary checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramname">key</td><td>values that will be computed, an array of fixed size 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if point is within the octree (valid), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a00f9d0f17d3d981bb79d4596a2495ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKeyChecked </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a 3D coordinate into a 3D <a class="el" href="classoctomap_1_1OcTreeKey.html" title="OcTreeKey is a container class for internal key addressing.">OcTreeKey</a> at a certain depth, with boundary checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramname">depth</td><td>level of the key from the top </td></tr>
    <tr><td class="paramname">key</td><td>values that will be computed, an array of fixed size 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if point is within the octree (valid), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab7b2f83da4effcde89744a6f2a5caa1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKeyChecked </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short int &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a single coordinate into a discrete addressing key, with boundary checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinate</td><td>3d coordinate of a point </td></tr>
    <tr><td class="paramname">key</td><td>discrete 16 bit adressing key, result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if coordinate is within the octree bounds (valid), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a0d1519c245cd5c7782e9c5652444908f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::coordToKeyChecked </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short int &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a single coordinate into a discrete addressing key, with boundary checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinate</td><td>3d coordinate of a point </td></tr>
    <tr><td class="paramname">depth</td><td>level of the key from the top </td></tr>
    <tr><td class="paramname">key</td><td>discrete 16 bit adressing key, result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if coordinate is within the octree bounds (valid), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a787f843eb5639731742a248aa7ff800a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTree.html">OcTree</a>* octomap::OcTree::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual constructor: creates a new object of same type (Covariant return type requires an up-to-date compiler) </p>

<p>References <a class="el" href="classoctomap_1_1OcTree.html#a08375ca02aff5117437ab2a417c8e062">OcTree()</a>, and <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5f2d51a206f715936d443367b580b6c5">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::resolution</a>.</p>

</div>
</div>
<a class="anchor" id="a36f9f15a9a4504616305a356db641de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::deleteNode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a node (if exists) given a 3d point. </p>
<p>Will always delete at the lowest level unless depth !=0, and expand pruned inner nodes as needed. Pruned nodes at level "depth" will directly be deleted as a whole. </p>

<p>References <a class="el" href="octomap__types_8h.html#a86314c002a60ea0964b947f5109ac75e">OCTOMAP_ERROR_STR</a>.</p>

</div>
</div>
<a class="anchor" id="a31b6836c77ae48c3c550b9b786d67fc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::deleteNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a node (if exists) given a 3d point. </p>
<p>Will always delete at the lowest level unless depth !=0, and expand pruned inner nodes as needed. Pruned nodes at level "depth" will directly be deleted as a whole. </p>

<p>References <a class="el" href="octomap__types_8h.html#a86314c002a60ea0964b947f5109ac75e">OCTOMAP_ERROR_STR</a>.</p>

</div>
</div>
<a class="anchor" id="abc170f9acea68c32ade0fd923f4f8ca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::deleteNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a node (if exists) given an addressing key. </p>
<p>Will always delete at the lowest level unless depth !=0, and expand pruned inner nodes as needed. Pruned nodes at level "depth" will directly be deleted as a whole. </p>

</div>
</div>
<a class="anchor" id="ae00cde0edc00cfad27057ec438f8c9a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::deleteNodeRecurs </td>
          <td>(</td>
          <td class="paramtype">NODE *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursive call of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a36f9f15a9a4504616305a356db641de2" title="Delete a node (if exists) given a 3d point.">deleteNode()</a> </p>

<p>References <a class="el" href="namespaceoctomap.html#a60fec7525fc7e99466abc53d03bffa8f">octomap::computeChildIdx()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cc466fc662fe007f218fd5f51f3edba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::enableChangeDetection </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>track or ignore changes while inserting scans (default: ignore) </p>

</div>
</div>
<a class="anchor" id="a265bf03a26a4975020f86560cff2c75a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a8a4033eb7e0956b56cb5307ecf9df579">iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end of the tree as leaf iterator </dd></dl>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeStamped.html#a480c6d2c4308c8b5017bed9f2b5f56b1">octomap::OcTreeStamped::degradeOutdatedNodes()</a>, <a class="el" href="bt2vrml_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="classoctomap_1_1ColorOcTree.html#a7e6e3776997e10b7d651b82fd427c8bc">octomap::ColorOcTree::writeColorHistogram()</a>.</p>

</div>
</div>
<a class="anchor" id="a61102e126b93cdfc45b9a37d25805ae8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classleaf__iterator.html">leaf_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::end_leafs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end of the tree as leaf iterator </dd></dl>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeStamped.html#a480c6d2c4308c8b5017bed9f2b5f56b1">octomap::OcTreeStamped::degradeOutdatedNodes()</a>, and <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bd3f68af78f3d94fa1b6e50dcf80fc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::end_leafs_bbx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end of the tree as leaf iterator in a bounding box </dd></dl>

</div>
</div>
<a class="anchor" id="a3c16e679eea7a505d56a0113fc0e6a22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtree__iterator.html">tree_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::end_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end of the tree as iterator to all nodes (incl. inner) </dd></dl>

<p>Referenced by <a class="el" href="graph2tree_8cpp.html#a48a6bc54cffc48e72d9b5a7712757ad4">calcThresholdedNodes()</a>, <a class="el" href="test__iterators_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::operator==()</a>, <a class="el" href="test__changedkeys_8cpp.html#a427f20c2f8fea069265c6d60e46fc695">printChanges()</a>, and <a class="el" href="classoctomap_1_1ColorOcTree.html#a7e6e3776997e10b7d651b82fd427c8bc">octomap::ColorOcTree::writeColorHistogram()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b70e9de34c61f1f47c51d57e62b83ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::expand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands all pruned nodes (reverse of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31132b9fc0e9c3ffd620e53b12148443" title="Lossless compression of the octree: A node will replace all of its eight children if they have identi...">prune()</a>) </p>
<dl class="section note"><dt>Note</dt><dd>This is an expensive operation, especially when the tree is nearly empty! </dd></dl>

<p>Referenced by <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="test__changedkeys_8cpp.html#a427f20c2f8fea069265c6d60e46fc695">printChanges()</a>.</p>

</div>
</div>
<a class="anchor" id="a57f15113fcb61fee6b677a3956937f7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::expandRecurs </td>
          <td>(</td>
          <td class="paramtype">NODE *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursive call of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5b70e9de34c61f1f47c51d57e62b83ee" title="Expands all pruned nodes (reverse of prune())">expand()</a> </p>

</div>
</div>
<a class="anchor" id="abfad80701bca6864e43c76726b0df7da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::getBBXBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf505a163b211dd7678caf01dbc2f4ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::getBBXCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adcab0b70859881d0a2ef080af2356e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::getBBXMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set maximum for bounding box queries, if set </dd></dl>

</div>
</div>
<a class="anchor" id="a764ae6dd1a5ee22858ec0ba0f72cb768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::getBBXMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set minimum for bounding box queries, if set </dd></dl>

</div>
</div>
<a class="anchor" id="a157244a4f44de9e982584dc87a4efa73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getMetricMax </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum value of the bounding box of all known space in x, y, z </p>

</div>
</div>
<a class="anchor" id="aaa12a98cea1ddc04e0b59c21628a8a43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getMetricMax </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum value of the bounding box of all known space in x, y, z </p>

</div>
</div>
<a class="anchor" id="a1e9e2f524d14d02cf214cf8149e627ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getMetricMin </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>minimum value of the bounding box of all known space in x, y, z </p>

</div>
</div>
<a class="anchor" id="a3639ff639b1532e21e81cf32eb8489fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getMetricMin </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>minimum value of the bounding box of all known space in x, y, z </p>

</div>
</div>
<a class="anchor" id="ae38720a5b019b0aeece66d51dfb1e138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getMetricSize </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> (all known space) in meters for x, y and z dimension. </p>

<p>Referenced by <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="graph2tree_8cpp.html#af262a89a040a4e4d0c9c274d60a900d8">outputStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="ab74ef7bae2862ec0c5d98963fb2bbabb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getMetricSize </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> (all known space) in meters for x, y and z dimension. </p>

</div>
</div>
<a class="anchor" id="a48ba7b2eb65ed1ddbbccf04c48a560da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::getNodeSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a44daf1f70083202ac8277dc9574b1d9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::getNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unknownStatus</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a step of the marching cubes surface reconstruction algorithm to retreive the normal of the triangles that fall in the cube formed by the voxels located at the vertex of a given voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voxel</td><td>for which retreive the normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triangles</td><td>normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unknownStatus</td><td>consider unknown cells as free (false) or occupied (default, true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the input voxel is known in the occupancy grid, and false if it is unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8ba9b01d5e67118d2fd2e64547f1b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getNumLeafNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverses the tree to calculate the total number of leaf nodes. </p>

<p>Referenced by <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="graph2tree_8cpp.html#af262a89a040a4e4d0c9c274d60a900d8">outputStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="af1ef3f9fa8a01299183c994c37d8308a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getNumLeafNodesRecurs </td>
          <td>(</td>
          <td class="paramtype">const NODE *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad44ea7382488207c07d0fcbfff3772ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::getRayIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the entry point of a ray into a voxel. </p>
<p>This is the closest intersection point of the ray originating from origin and a plane of the axis aligned cube.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Starting point of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>A vector pointing in the direction of the raycast. Does not need to be normalized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the voxel where the ray terminated. This is the output of castRay. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection</td><td>The entry point of the ray into the voxel, on the voxel surface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>A small increment to avoid ambiguity of beeing exactly on a voxel surface. A positive value will get the point out of the hit voxel, while a negative valuewill get it inside. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not an intesection point has been found. Either, the ray never cross the voxel or the ray is exactly parallel to the only surface it intersect. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f052f60b7381a574d20d2e05d519ec4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::getResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="test__iterators_8cpp.html#a6d0d0c5419db07d6a4bafb7ab02fb5e6">getLeafNodesRecurs()</a>, and <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a35ac605b40608c122241cc530833a5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NODE* <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root node of the tree. This pointer should not be modified or deleted externally, the <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> manages its memory itself. In an empty tree, root is NULL. </dd></dl>

<p>Referenced by <a class="el" href="test__iterators_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a9736e60909414430b8d4acac397c6942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::getTreeDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac05c4557c0c6f57ae46ba22bb282c0a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string octomap::OcTree::getTreeType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a79e0b2e2456f53c57958f42b7cba9654">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6e162cee6011e1fec8933a331817aa00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::getUnknownLeafCenters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a435066a1f3df3ffeecc24db9cd3a5be0">point3d_list</a> &amp;&#160;</td>
          <td class="paramname"><em>node_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td>
          <td class="paramname"><em>pmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a>&#160;</td>
          <td class="paramname"><em>pmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return centers of leafs that do NOT exist (but could) in a given bounding box </p>

<p>References <a class="el" href="classoctomath_1_1Vector3.html#adc2410ec4c9b0521a4f170309e8fde42">octomath::Vector3::x()</a>, <a class="el" href="classoctomath_1_1Vector3.html#af83235721a5631bee05bf226a0391342">octomath::Vector3::y()</a>, and <a class="el" href="classoctomath_1_1Vector3.html#af853f87d953c81f11de8ee14226e5f51">octomath::Vector3::z()</a>.</p>

</div>
</div>
<a class="anchor" id="a65963bf3e34131f640e87fbdb987d239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::inBBX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if point is in the currently set bounding box </dd></dl>

</div>
</div>
<a class="anchor" id="aba9b7931ffdfdf8b0df4c3489d015e54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::inBBX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if key is in the currently set bounding box </dd></dl>

</div>
</div>
<a class="anchor" id="ac054acf73b2f7e8f509c7fa695169aa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize non-trivial members, helper for constructors </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#afa27c55b62049ef3d0c845addab19690">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::OcTreeBaseImpl()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c6d38e8a7028416cd23449f14e215e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::insertPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">octomap::point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>sensor_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discretize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate a Pointcloud (in global reference frame), parallelized with OpenMP. </p>
<p>Special care is taken that each voxel in the map is updated only once, and occupied nodes have a preference over free ones. This avoids holes in the floor from mutual deletion and is more efficient than the plain ray insertion in insertPointCloudRays().</p>
<dl class="section note"><dt>Note</dt><dd>replaces insertScan()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>Pointcloud (measurement endpoints), in global reference frame </td></tr>
    <tr><td class="paramname">sensor_origin</td><td>measurement origin in global reference frame </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range for how long individual beams are inserted (default -1: complete beam) </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
    <tr><td class="paramname">discretize</td><td>whether the scan is discretized first into octree key cells (default: false). This reduces the number of raycasts using computeDiscreteUpdate(), resulting in a potential speedup.* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cbe73ddb6095403a1e8a28bd4aeeb90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::insertPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>sensor_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a6bd8a48b69816a376984cc55af3887e3">pose6d</a> &amp;&#160;</td>
          <td class="paramname"><em>frame_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discretize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate a 3d scan (transform scan before tree update), parallelized with OpenMP. </p>
<p>Special care is taken that each voxel in the map is updated only once, and occupied nodes have a preference over free ones. This avoids holes in the floor from mutual deletion and is more efficient than the plain ray insertion in insertPointCloudRays().</p>
<dl class="section note"><dt>Note</dt><dd>replaces insertScan()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>Pointcloud (measurement endpoints) relative to frame origin </td></tr>
    <tr><td class="paramname">sensor_origin</td><td>origin of sensor relative to frame origin </td></tr>
    <tr><td class="paramname">frame_origin</td><td>origin of reference frame, determines transform to be applied to cloud and sensor origin </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range for how long individual beams are inserted (default -1: complete beam) </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
    <tr><td class="paramname">discretize</td><td>whether the scan is discretized first into octree key cells (default: false). This reduces the number of raycasts using computeDiscreteUpdate(), resulting in a potential speedup.* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38596f336dede671ef08815400bc87f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::insertPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1ScanNode.html">ScanNode</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discretize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a 3d scan (given as a ScanNode) into the tree, parallelized with OpenMP. </p>
<dl class="section note"><dt>Note</dt><dd>replaces insertScan</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>ScanNode contains Pointcloud data and frame/sensor origin </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range for how long individual beams are inserted (default -1: complete beam) </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether the tree is left 'dirty' after the update (default: false). This speeds up the insertion by not updating inner nodes, but you need to call updateInnerOccupancy() when done. </td></tr>
    <tr><td class="paramname">discretize</td><td>whether the scan is discretized first into octree key cells (default: false). This reduces the number of raycasts using computeDiscreteUpdate(), resulting in a potential speedup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82a4f48761792bc15549eaa6d3fd03b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::insertPointCloudRays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1Pointcloud.html">Pointcloud</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>sensor_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate a Pointcloud (in global reference frame), parallelized with OpenMP. </p>
<p>This function simply inserts all rays of the point clouds as batch operation. Discretization effects can lead to the deletion of occupied space, it is usually recommended to use insertPointCloud() instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>Pointcloud (measurement endpoints), in global reference frame </td></tr>
    <tr><td class="paramname">sensor_origin</td><td>measurement origin in global reference frame </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range for how long individual beams are inserted (default -1: complete beam) </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c1c2678e33a791df715affa6ea03dcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::insertRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxrange</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one ray between origin and end into the tree. </p>
<p>integrateMissOnRay() is called for the ray, the end point is updated as occupied. It is usually more efficient to insert complete pointcloudsm with insertPointCloud() or insertPointCloudRays().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>origin of sensor in global coordinates </td></tr>
    <tr><td class="paramname">end</td><td>endpoint of measurement in global coordinates </td></tr>
    <tr><td class="paramname">maxrange</td><td>maximum range after which the raycast should be aborted </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ab6a76668ab47e521b5162c825f2eb35d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::integrateHit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>occupancyNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>integrate a "hit" measurement according to the tree's sensor model </p>

</div>
</div>
<a class="anchor" id="a3630893a9d7c18465642bde15eab21da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::integrateMiss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>occupancyNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>integrate a "miss" measurement according to the tree's sensor model </p>

</div>
</div>
<a class="anchor" id="aaa4024dfb0d825e8e10299ad9d55ff8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::integrateMissOnRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traces a ray from origin to end and updates all voxels on the way as free. </p>
<p>The volume containing "end" is not updated. </p>

</div>
</div>
<a class="anchor" id="ada5b1fad301a07b098c229910baa7f19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::keyToCoord </td>
          <td>(</td>
          <td class="paramtype">unsigned short int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts from a discrete key at a given depth into a coordinate corresponding to the key's center </p>

<p>Referenced by <a class="el" href="classoctomap_1_1CountingOcTree.html#aaf8af0604f5f7adfe0ec1127547d82b6">octomap::CountingOcTree::getCentersMinHitsRecurs()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3de7659d12e4de108e0f070b3e9ac9d1">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::keyToCoord()</a>, and <a class="el" href="unit__tests_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ace5cef22807b62454614955a0862000a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::keyToCoord </td>
          <td>(</td>
          <td class="paramtype">unsigned short int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts from a discrete key at the lowest tree level into a coordinate corresponding to the key's center </p>

</div>
</div>
<a class="anchor" id="a3de7659d12e4de108e0f070b3e9ac9d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::keyToCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts from an addressing key at the lowest tree level into a coordinate corresponding to the key's center </p>

</div>
</div>
<a class="anchor" id="a16e90e4afd4c980eca1a70be130fa929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::keyToCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts from an addressing key at a given depth into a coordinate corresponding to the key's center </p>

</div>
</div>
<a class="anchor" id="a6768db61ca2fc3ad28af756e46c34621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::memoryFullGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Memory usage of a full grid of the same size as the <a class="el" href="classoctomap_1_1OcTree.html" title="octomap main map data structure, stores 3D occupancy grid map in an OcTree.">OcTree</a> in bytes (for comparison) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this can be larger than the adressable memory - size_t may not be enough to hold it! </dd></dl>

<p>Referenced by <a class="el" href="graph2tree_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="graph2tree_8cpp.html#af262a89a040a4e4d0c9c274d60a900d8">outputStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ddd7627880a6b1ec1fd93695065e267"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::memoryUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Memory usage of the complete octree in bytes (may vary between architectures) </dd></dl>

<p>Referenced by <a class="el" href="graph2tree_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="graph2tree_8cpp.html#af262a89a040a4e4d0c9c274d60a900d8">outputStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="afca4716278c2e810da682362f979291c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::memoryUsageNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Memory usage of a single octree node </dd></dl>

</div>
</div>
<a class="anchor" id="a7b5973d41a60f4a4ccf07ca9916c7142"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::nodeToMaxLikelihood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>occupancyNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts the node to the maximum likelihood value according to the tree's parameter for "occupancy" </p>

</div>
</div>
<a class="anchor" id="aea2310e44ca5203e12f9fbabe8a7d285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::nodeToMaxLikelihood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &amp;&#160;</td>
          <td class="paramname"><em>occupancyNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts the node to the maximum likelihood value according to the tree's parameter for "occupancy" </p>

</div>
</div>
<a class="anchor" id="a1741fb38f33d05b8df8675831cf21824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::OCTOMAP_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">virtual void&#160;</td>
          <td class="paramname"><em>insertScan</em>const Pointcloud &amp;scan, const octomap::point3d &amp;sensor_origin,double maxrange=-1., bool pruning=true, bool lazy_eval=false</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Deprecated, use insertPointCloud() instead. pruning is now done automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="a794e2d1a868a0616c52d27f22ee1bef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::OCTOMAP_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">virtual void&#160;</td>
          <td class="paramname"><em>insertScan</em>const Pointcloud &amp;scan, const point3d &amp;sensor_origin,const pose6d &amp;frame_origin, double maxrange=-1., bool pruning=true, bool lazy_eval=false</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Deprecated, use insertPointCloud() instead. pruning is now done automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d9018a31c23800af74ffce843b034e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::OCTOMAP_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">virtual void&#160;</td>
          <td class="paramname"><em>insertScan</em>const ScanNode &amp;scan, double maxrange=-1., bool pruning=true, bool lazy_eval=false</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Deprecated, use insertPointCloud() instead. pruning is now done automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="a457982340024978bbd98edb81661a33a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::OCTOMAP_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">virtual void&#160;</td>
          <td class="paramname"><em>insertScanNaive</em>const Pointcloud &amp;scan, const point3d &amp;sensor_origin, double maxrange, bool lazy_eval=false</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Deprecated, use insertPointCloudRays instead. pruning is now done automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e8184d78950217466f56ac031384d08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">OcTreeBaseImpl</a>&lt; NODE, I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison between two octrees, all meta data, all nodes, and the structure must be identical. </p>

<p>References <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a08e9a98276ccbfcb19cf9390f9bd2f3f">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::begin_tree()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3c16e679eea7a505d56a0113fc0e6a22">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::end_tree()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a5f2d51a206f715936d443367b580b6c5">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::resolution</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a54a46a920d1b6bea565ecb3aec4836e0">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::tree_depth</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a09f8c5c9275c0d56af2f8c9b5bb463c6">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::tree_max_val</a>, and <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ad8ffbc2b6a76a338095974e7b03a7365">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::tree_size</a>.</p>

</div>
</div>
<a class="anchor" id="a31132b9fc0e9c3ffd620e53b12148443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::prune </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lossless compression of the octree: A node will replace all of its eight children if they have identical values. </p>
<p>You usually don't have to call <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31132b9fc0e9c3ffd620e53b12148443" title="Lossless compression of the octree: A node will replace all of its eight children if they have identi...">prune()</a> after a regular occupancy update, updateNode() incrementally prunes all affected nodes. </p>

<p>Referenced by <a class="el" href="binvox2bt_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="test__changedkeys_8cpp.html#a427f20c2f8fea069265c6d60e46fc695">printChanges()</a>.</p>

</div>
</div>
<a class="anchor" id="a97fc800f63229de112a223cfef6e8c84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::pruneRecurs </td>
          <td>(</td>
          <td class="paramtype">NODE *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>num_pruned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursive call of <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31132b9fc0e9c3ffd620e53b12148443" title="Lossless compression of the octree: A node will replace all of its eight children if they have identi...">prune()</a> </p>

</div>
</div>
<a class="anchor" id="ac0c3b21746b1034254779db716cf8b22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::readBinaryData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads only the data (=complete tree structure) from the input stream. </p>
<p>The tree needs to be constructed with the proper header information beforehand, see readBinary(). </p>

</div>
</div>
<a class="anchor" id="a7efd5dd976f5d8caed1f689ed34c70d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::readBinaryNode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node from binary stream (max-likelihood value), recursively continue with all children. </p>
<p>This will set the log_odds_occupancy value of all leaves to either free or occupied. </p>

</div>
</div>
<a class="anchor" id="a041de5911e0332964e5c21cd42025955"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all nodes from the input stream (without file header), for this the tree needs to be already created. </p>
<p>For general file IO, you should probably use <a class="el" href="classoctomap_1_1AbstractOcTree.html#a3cc5d66ac5d73e4415104b1fb35c00bd" title="Read the file header, create the appropriate class and deserialize.">AbstractOcTree::read()</a> instead. </p>

<p>References <a class="el" href="octomap__types_8h.html#a86314c002a60ea0964b947f5109ac75e">OCTOMAP_ERROR_STR</a>, and <a class="el" href="octomap__types_8h.html#ab0641214b665cad32c6f3c8f1cc8ff69">OCTOMAP_WARNING_STR</a>.</p>

<p>Referenced by <a class="el" href="convert__octree_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1b94303bdfff6c27547c0d5f7085017"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::resetChangeDetection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the set of changed keys. Call this after you obtained all changed nodes. </p>

</div>
</div>
<a class="anchor" id="a6db68c9dd1eef46e6343edcc9448a5ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NODE * <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::search </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search node at specified depth given a 3d point (depth=0: search full tree depth). </p>
<p>You need to check if the returned node is NULL, since it can be in unknown space. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to node if found, NULL otherwise </dd></dl>

<p>References <a class="el" href="octomap__types_8h.html#a86314c002a60ea0964b947f5109ac75e">OCTOMAP_ERROR_STR</a>.</p>

<p>Referenced by <a class="el" href="classoctomap_1_1ColorOcTree.html#ad436f105df97668234b4836bcafe2dc8">octomap::ColorOcTree::averageNodeColor()</a>, <a class="el" href="classoctomap_1_1ColorOcTree.html#a95d3f18592fd8e41d35a797dbba21a58">octomap::ColorOcTree::integrateNodeColor()</a>, <a class="el" href="compare__octrees_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="test__changedkeys_8cpp.html#a427f20c2f8fea069265c6d60e46fc695">printChanges()</a>, and <a class="el" href="classoctomap_1_1ColorOcTree.html#a3da9187a5c57a38519dd875754798376">octomap::ColorOcTree::setNodeColor()</a>.</p>

</div>
</div>
<a class="anchor" id="ae73a920481fa4701c7f89c34f4ab2f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NODE * <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search node at specified depth given a 3d point (depth=0: search full tree depth) You need to check if the returned node is NULL, since it can be in unknown space. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to node if found, NULL otherwise </dd></dl>

<p>References <a class="el" href="octomap__types_8h.html#a86314c002a60ea0964b947f5109ac75e">OCTOMAP_ERROR_STR</a>.</p>

</div>
</div>
<a class="anchor" id="ab45f108891eb301805392e164565353f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NODE * <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a node at specified depth given an addressing key (depth=0: search full tree depth) You need to check if the returned node is NULL, since it can be in unknown space. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to node if found, NULL otherwise </dd></dl>

<p>References <a class="el" href="namespaceoctomap.html#a60fec7525fc7e99466abc53d03bffa8f">octomap::computeChildIdx()</a>.</p>

</div>
</div>
<a class="anchor" id="a20440262a32b80919913417e87385645"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::setBBXMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the maximum for a query bounding box to use </p>

</div>
</div>
<a class="anchor" id="a42cd4dc782682358ec1651ea14ec3316"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::setBBXMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the minimum for a query bounding box to use </p>

</div>
</div>
<a class="anchor" id="a652a65d9654982e3d2f6c7528a48f2b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::setNodeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set log_odds value of voxel to log_odds_value. </p>
<p>This only works if key is at the lowest octree level</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>OcTreeKey of the NODE that is to be updated </td></tr>
    <tr><td class="paramname">log_odds_update</td><td>value to be added (+) to log_odds value of node </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="a6c251537105ba0249ab2cb4299f72001"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::setNodeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set log_odds value of voxel to log_odds_value. </p>
<p>Looks up the OcTreeKey corresponding to the coordinate and then calls setNodeValue() with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>3d coordinate of the NODE that is to be updated </td></tr>
    <tr><td class="paramname">log_odds_update</td><td>value to be added (+) to log_odds value of node </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="abe8ab09bde82ca578ba54eebd7c85f13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::setNodeValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set log_odds value of voxel to log_odds_value. </p>
<p>Looks up the OcTreeKey corresponding to the coordinate and then calls setNodeValue() with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramname">log_odds_update</td><td>value to be added (+) to log_odds value of node </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="af68159ed27df340f6930ec481a8b7a53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::setNodeValueRecurs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>node_just_created</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>log_odds_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ad4d6dd0659abbe639c5ce5f1d6c4a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::setResolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the resolution of the octree, scaling all voxels. This will not preserve the (metric) scale! </p>

<p>Referenced by <a class="el" href="edit__octree_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a61a371f276bd00516080c05a76a8be38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the tree </dd></dl>

<p>Referenced by <a class="el" href="convert__octree_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, and <a class="el" href="graph2tree_8cpp.html#af262a89a040a4e4d0c9c274d60a900d8">outputStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="a83584b21b3cd286552797a6a4f4b159c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::swapContent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">OcTreeBaseImpl</a>&lt; NODE, I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap contents of two octrees, i.e., only the underlying pointer / tree structure. </p>
<p>You have to ensure yourself that the metadata (resolution etc) matches. No memory is cleared in this function </p>

<p>References <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#aebd8f6d931c30b559055a3ad3376aa11">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::root</a>, and <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ad8ffbc2b6a76a338095974e7b03a7365">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::tree_size</a>.</p>

</div>
</div>
<a class="anchor" id="ae0846e72f5f4e772561bc6f1f8430042"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::toMaxLikelihood </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the maximum likelihood map by calling toMaxLikelihood on all tree nodes, setting their occupancy to the corresponding occupancy thresholds. </p>
<p>This enables a very efficient compression if you call prune() afterwards. </p>

</div>
</div>
<a class="anchor" id="afd9a64204726215c65c80386ada661dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::toMaxLikelihoodRecurs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a250f77b38dfd4eafe5d954979d77d0e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateInnerOccupancy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the occupancy of all inner nodes to reflect their children's occupancy. </p>
<p>If you performed batch-updates with lazy evaluation enabled, you must call this before any queries to ensure correct multi-resolution behavior. </p>

</div>
</div>
<a class="anchor" id="ae79d100be1e5eb3d55c1a91751df28c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateInnerOccupancyRecurs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a395884de10ad8de0696afb09636bc2e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate log_odds value of a voxel by changing it by log_odds_update (relative). </p>
<p>This only works if key is at the lowest octree level</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>OcTreeKey of the NODE that is to be updated </td></tr>
    <tr><td class="paramname">log_odds_update</td><td>value to be added (+) to log_odds value of node </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="ae64055da494c7f5254cbfe83c1e65512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate log_odds value of a voxel by changing it by log_odds_update (relative). </p>
<p>Looks up the OcTreeKey corresponding to the coordinate and then calls updateNode() with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>3d coordinate of the NODE that is to be updated </td></tr>
    <tr><td class="paramname">log_odds_update</td><td>value to be added (+) to log_odds value of node </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="a7c46e7320b83fa8a2272069d464c4e43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate log_odds value of a voxel by changing it by log_odds_update (relative). </p>
<p>Looks up the OcTreeKey corresponding to the coordinate and then calls updateNode() with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramname">log_odds_update</td><td>value to be added (+) to log_odds value of node </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="abc504262dd5f8f98d479919ac2d8889e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate occupancy measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>OcTreeKey of the NODE that is to be updated </td></tr>
    <tr><td class="paramname">occupied</td><td>true if the node was measured occupied, else false </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="a389413ab0fe00fabe641cb8268c903cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate occupancy measurement. </p>
<p>Looks up the OcTreeKey corresponding to the coordinate and then calls udpateNode() with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>3d coordinate of the NODE that is to be updated </td></tr>
    <tr><td class="paramname">occupied</td><td>true if the node was measured occupied, else false </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="a97c0ef2c7d0766f0ac0b9c861daf6d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>occupied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate occupancy measurement. </p>
<p>Looks up the OcTreeKey corresponding to the coordinate and then calls udpateNode() with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramname">occupied</td><td>true if the node was measured occupied, else false </td></tr>
    <tr><td class="paramname">lazy_eval</td><td>whether update of inner nodes is omitted after the update (default: false). This speeds up the insertion, but you need to call updateInnerOccupancy() when done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the updated NODE </dd></dl>

</div>
</div>
<a class="anchor" id="a1cc8f1d331e06920b8605863bdd271d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNodeLogOdds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>occupancyNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update logodds value of node by adding to the current value. </p>

</div>
</div>
<a class="anchor" id="abf29213fc595d17e2a83aed551166473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a> * <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::updateNodeRecurs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>node_just_created</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>log_odds_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy_eval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a055f971c772215c974c2fe4cec183e9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::useBBXLimit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>use or ignore BBX limit (default: ignore) </p>

</div>
</div>
<a class="anchor" id="aaeb5a6148103a127b1f94860803812ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16fa3cdb461dbe1889587c363e60a48f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::writeBinaryData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the data of the tree (without header) to the stream, recursively calling writeBinaryNode (starting with root) </p>

</div>
</div>
<a class="anchor" id="a2bf24c5a91cb4f0d6e478181c98b75c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::writeBinaryNode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write node to binary stream (max-likelihood value), recursively continue with all children. </p>
<p>This will discard the log_odds_occupancy value, writing all leaves as either free or occupied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">node</td><td>OcTreeNode to write out, will recurse to all children </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8e86a2b65a21ae07837ce08dc82aa1af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, I &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write complete state of tree to stream (without file header) unmodified. Pruning the tree first produces smaller files (lossless compression) </p>

</div>
</div>
<h2>Field Documentation</h2>
<a class="anchor" id="abdb60fb3020a5bb347167d1bfaa65335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::bbx_max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a40102a8e6d48ec09d576482a8fde9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::bbx_max_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a0841eef190e9eb6c07db41bc047f8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::bbx_min</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afd858331fd9954e545383520e324ff29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTreeKey.html">OcTreeKey</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::bbx_min_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a842d31e238713bfc8afe708e97b859b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a5f98f11c602d9fefec29ff55763e1d49">KeyBoolMap</a> <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::changed_keys</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set of leaf keys (lowest level) which changed since last resetChangeDetection. </p>

</div>
</div>
<a class="anchor" id="a6bd58a85177ebd36b1dfed18a95ab965"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classoctomap_1_1KeyRay.html">KeyRay</a>&gt; <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::keyrays</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>data structure for ray casting, array for multithreading </p>

</div>
</div>
<a class="anchor" id="a0d644d0caf31705312a94d8091ead298"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classleaf__bbx__iterator.html">leaf_bbx_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::leaf_iterator_bbx_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a7bd3f68af78f3d94fa1b6e50dcf80fc7">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::end_leafs_bbx()</a>.</p>

</div>
</div>
<a class="anchor" id="af265e3a9c552cd90eb1101cb248c2736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classleaf__iterator.html">leaf_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::leaf_iterator_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a265bf03a26a4975020f86560cff2c75a">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::end()</a>, and <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a61102e126b93cdfc45b9a37d25805ae8">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::end_leafs()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a3d5448647090d1ef19eae1e3fafd0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::max_value[3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>max in x, y, z </p>

</div>
</div>
<a class="anchor" id="aecaa47e50bb18d56d9401854354fbd90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::min_value[3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>min in x, y, z contains the size of a voxel at level i (0: root node). tree_depth+1 levels (incl. 0) </p>

</div>
</div>
<a class="anchor" id="af913dc3ca39d6b18855b54d6d52e5307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoctomap_1_1OcTree_1_1StaticMemberInitializer.html">OcTree::StaticMemberInitializer</a> octomap::OcTree::ocTreeMemberInit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to ensure static initialization (only once) </p>

</div>
</div>
<a class="anchor" id="a5f2d51a206f715936d443367b580b6c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::resolution</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>in meters </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTree.html#a787f843eb5639731742a248aa7ff800a">create()</a>, <a class="el" href="classoctomap_1_1OcTreeStamped.html#a7c10acad7451b9ef7bb4a61080f1a5c2">octomap::OcTreeStamped::create()</a>, <a class="el" href="classoctomap_1_1ColorOcTree.html#a3f77f70576bb61abc7894e10d33c9979">octomap::ColorOcTree::create()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9f052f60b7381a574d20d2e05d519ec4">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::getResolution()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ace5cef22807b62454614955a0862000a">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::keyToCoord()</a>, and <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b422a040cdd65ae18e26334bb03f35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::resolution_factor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= 1. / resolution </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31c53676e6900005297812fbc78b10e0">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::coordToKey()</a>.</p>

</div>
</div>
<a class="anchor" id="aebd8f6d931c30b559055a3ad3376aa11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NODE* <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the root NODE, NULL for empty tree. </p>

<p>Referenced by <a class="el" href="classoctomap_1_1CountingOcTree.html#a6ef758820d7db4066e96d74ccd3c7605">octomap::CountingOcTree::getCentersMinHits()</a>, <a class="el" href="classoctomap_1_1OcTreeStamped.html#a29c595c596e943052bccdfe38363cd90">octomap::OcTreeStamped::getLastUpdateTime()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a35ac605b40608c122241cc530833a5b5">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::getRoot()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a4075202da456b3103a0fb9aa42a05198">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::OcTreeBaseImpl()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a83584b21b3cd286552797a6a4f4b159c">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::swapContent()</a>, <a class="el" href="classoctomap_1_1ColorOcTree.html#a341fc7913858d410ad1bbe40e451d3d6">octomap::ColorOcTree::updateInnerOccupancy()</a>, and <a class="el" href="classoctomap_1_1CountingOcTree.html#a4854f8e86347e1392fc3eb67f2a7b13a">octomap::CountingOcTree::updateNode()</a>.</p>

</div>
</div>
<a class="anchor" id="acb759f973505d25813717166300266b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::size_changed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb09478c7fb5dbe6fc271b066876584e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::sizeLookupTable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a48ba7b2eb65ed1ddbbccf04c48a560da">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::getNodeSize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1c4753f4bf09c85d8856f1151bcee56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoctomap.html#a7bc37f6465df7e66a7dccd16859637d7">point3d</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::tree_center</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a54a46a920d1b6bea565ecb3aec4836e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::tree_depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum tree depth is fixed to 16 currently. </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#abf9bcd38f98a73eb0f0f2b395a8b5f62">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::adjustKeyAtDepth()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a61df881d6eabc33f886134c9c9801166">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::coordToKey()</a>, <a class="el" href="classoctomap_1_1CountingOcTree.html#a6ef758820d7db4066e96d74ccd3c7605">octomap::CountingOcTree::getCentersMinHits()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a48ba7b2eb65ed1ddbbccf04c48a560da">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::getNodeSize()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9736e60909414430b8d4acac397c6942">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::getTreeDepth()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::operator==()</a>, <a class="el" href="classoctomap_1_1ColorOcTree.html#a9ee485283eb9a761e3b212465b4f3012">octomap::ColorOcTree::updateInnerOccupancyRecurs()</a>, and <a class="el" href="classoctomap_1_1CountingOcTree.html#a4854f8e86347e1392fc3eb67f2a7b13a">octomap::CountingOcTree::updateNode()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d0a6c8b9d69baaabff6d840c531a223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtree__iterator.html">tree_iterator</a> <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::tree_iterator_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a3c16e679eea7a505d56a0113fc0e6a22">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::end_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a09f8c5c9275c0d56af2f8c9b5bb463c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::tree_max_val</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a31c53676e6900005297812fbc78b10e0">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::coordToKey()</a>, <a class="el" href="classoctomap_1_1CountingOcTree.html#a6ef758820d7db4066e96d74ccd3c7605">octomap::CountingOcTree::getCentersMinHits()</a>, <a class="el" href="classoctomap_1_1CountingOcTree.html#aaf8af0604f5f7adfe0ec1127547d82b6">octomap::CountingOcTree::getCentersMinHitsRecurs()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#ace5cef22807b62454614955a0862000a">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::keyToCoord()</a>, and <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8ffbc2b6a76a338095974e7b03a7365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE, class INTERFACE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html">octomap::OcTreeBaseImpl</a>&lt; NODE, INTERFACE &gt;::tree_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of nodes in tree flag to denote whether the octree extent changed (for lazy min/max eval) </p>

<p>Referenced by <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a9e8184d78950217466f56ac031384d08">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::operator==()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a61a371f276bd00516080c05a76a8be38">octomap::OcTreeBaseImpl&lt; CountingOcTreeNode, AbstractOcTree &gt;::size()</a>, <a class="el" href="classoctomap_1_1OcTreeBaseImpl.html#a83584b21b3cd286552797a6a4f4b159c">octomap::OcTreeBaseImpl&lt; NODE, INTERFACE &gt;::swapContent()</a>, and <a class="el" href="classoctomap_1_1CountingOcTree.html#a4854f8e86347e1392fc3eb67f2a7b13a">octomap::CountingOcTree::updateNode()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ad82f344d43a0558d69b9113a4c257"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::use_bbx_limit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>use bounding box for queries (needs to be set)? </p>

</div>
</div>
<a class="anchor" id="a8a220400856023e41706e810fe724508"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoctomap_1_1OccupancyOcTreeBase.html">octomap::OccupancyOcTreeBase</a>&lt; <a class="el" href="classoctomap_1_1OcTreeNode.html">OcTreeNode</a>  &gt;::use_change_detection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/octomap/<a class="el" href="OcTree_8h_source.html">OcTree.h</a></li>
<li>src/<a class="el" href="OcTree_8cpp.html">OcTree.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoctomap.html">octomap</a></li><li class="navelem"><a class="el" href="classoctomap_1_1OcTree.html">OcTree</a></li>
    <li class="footer">Generated on Mon Jan 13 2014 11:57:31 for octomap by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
